<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo</title>

  
  <meta name="author" content="John Doe">
  

  
  <meta name="description" content="一、多线程简介1、多线程的由来一个进程（进程）在执行一个线程（线程中有很多函数或方法（后面简称Function））的时候，其中有一个Function执行的时候需要消耗一些时间，但是这个线程又必须同时执行这个Function之后的Function，问题来了，一个线程中的任何一个Function都必须等">
  

  
  
  <meta name="keywords" content="">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  

  <meta property="og:site_name" content="Hexo"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">Hexo</a>
    </h1>
    <p class="site-description"></p>
  </div>
  <nav class="site-navigation">
    <ul>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span></span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2023/03/24/2023:3:24/iOS多线程/" rel="bookmark">
        <time class="entry-date published" datetime="2023-03-24T03:55:38.078Z">
          2023-03-24
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="一、多线程简介"><a href="#一、多线程简介" class="headerlink" title="一、多线程简介"></a>一、多线程简介</h1><h2 id="1、多线程的由来"><a href="#1、多线程的由来" class="headerlink" title="1、多线程的由来"></a>1、多线程的由来</h2><p><strong>一个进程（进程）在执行一个线程（线程中有很多函数或方法（后面简称Function））的时候，其中有一个Function执行的时候需要消耗一些时间，但是这个线程又必须同时执行这个Function之后的Function，问题来了，一个线程中的任何一个Function都必须等待其执行完成后才能执行后面的Function，如果要同时执行两个或者多个Function，那么，就必须多开一个或者多个线程，这就是多线程的产生。我想多线程最开始的诞生就是由这而来吧！</strong></p>
<h2 id="2、耗时操作的模拟试验"><a href="#2、耗时操作的模拟试验" class="headerlink" title="2、耗时操作的模拟试验"></a>2、耗时操作的模拟试验</h2><h3 id="2-1-循环测试"><a href="#2-1-循环测试" class="headerlink" title="2.1 循环测试"></a>2.1 循环测试</h3><p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">        @autoreleasepool &#123;</span><br><span class="line">            NSLog(@&quot;bengin&quot;);</span><br><span class="line">            for (int i = 0; i &lt; 10000000; i++) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            NSLog(@&quot;end&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>控制台</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2016-02-16 13:51:54.140 Test[1670:603696] bengin  </span><br><span class="line">2016-02-16 13:51:54.160 Test[1670:603696] end  </span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>

<p><code>结论一：循环一亿次耗时0.02秒，计算机的运行速度是非常快的</code></p>
<h3 id="2-2-操作栈区"><a href="#2-2-操作栈区" class="headerlink" title="2.2 操作栈区"></a>2.2 操作栈区</h3><p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">        @autoreleasepool &#123;</span><br><span class="line">            NSLog(@&quot;bengin&quot;);</span><br><span class="line">            for (int i = 0; i &lt; 10000000; i++) &#123;</span><br><span class="line">                int n = 1;</span><br><span class="line">            &#125;</span><br><span class="line">            NSLog(@&quot;end&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p>控制台</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2016-02-16 13:57:37.589 Test[1734:631377] bengin  </span><br><span class="line">2016-02-16 13:57:37.612 Test[1734:631377] end  </span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>


<p><code>结论二：对栈区操作一亿次，耗时0.023秒</code></p>
<h3 id="2-3-操作常量区"><a href="#2-3-操作常量区" class="headerlink" title="2.3 操作常量区"></a>2.3 操作常量区</h3><p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        NSLog(@&quot;bengin&quot;);</span><br><span class="line">        for (int i = 0; i &lt; 10000000; i++) &#123;</span><br><span class="line">            NSString *str = @&quot;hellow&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        NSLog(@&quot;end&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>控制台</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2016-02-16 14:03:59.003 Test[1763:659287] bengin  </span><br><span class="line">2016-02-16 14:03:59.113 Test[1763:659287] end  </span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>

<p><code>结论三：对常量区操作一亿次，耗时0.11秒</code></p>
<h3 id="2-4-操作堆区"><a href="#2-4-操作堆区" class="headerlink" title="2.4 操作堆区"></a>2.4 操作堆区</h3><p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        NSLog(@&quot;bengin&quot;);</span><br><span class="line">        for (int i = 0; i &lt; 10000000; i++) &#123;</span><br><span class="line">            NSString *str = [NSString stringWithFormat:@&quot;%d&quot;,i];</span><br><span class="line">        &#125;</span><br><span class="line">        NSLog(@&quot;end&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>控制台</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2016-02-16 14:09:03.673 Test[1786:673719] bengin  </span><br><span class="line">2016-02-16 14:09:10.705 Test[1786:673719] end  </span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<p><code>结论四：对堆区操作一亿次耗时7秒多一些，较慢！</code></p>
<h3 id="2-5-I-x2F-O操作"><a href="#2-5-I-x2F-O操作" class="headerlink" title="2.5 I&#x2F;O操作"></a>2.5 I&#x2F;O操作</h3><p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        NSLog(@&quot;bengin&quot;);</span><br><span class="line">        for (int i = 0; i &lt; 10000000; i++) &#123;</span><br><span class="line">            NSLog(@&quot;%d&quot;,i);</span><br><span class="line">        &#125;</span><br><span class="line">        NSLog(@&quot;end&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>控制台输出！正在跑中，一亿次！！！先看截图<br>CPU  </p>
<p><img src="https://upload-images.jianshu.io/upload_images/1442184-06d31ec3a9fa3940.jpg" alt="CPU"></p>
<p>再看内存</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1442184-4618f1e39342f9ec.jpg" alt="内存"></p>
<p>好吧，还在跑，现在已经达到10分钟了，怕心疼本本炸掉！stop。。。<br><code>结论五：I/O操作非常慢，一亿次10分钟也没能跑完！</code></p>
<blockquote>
<p> <strong><code>最终结论：通过以上结论一、二、三、四、五得出一个结论，各个区的执行效率：栈区&gt;常量区&gt;堆区&gt;I/O操作。同时也说明了一个问题，执行不同的方法会产什么耗时操作。这是，为了解决耗时操作问题，多线程闪亮诞生！</code></strong></p>
</blockquote>
<h2 id="3、进程和线程"><a href="#3、进程和线程" class="headerlink" title="3、进程和线程"></a>3、进程和线程</h2><p>先说说进程和线程吧！</p>
<h3 id="3-1-进程"><a href="#3-1-进程" class="headerlink" title="3.1 进程"></a>3.1 进程</h3><h4 id="3-1-1-进程的概念："><a href="#3-1-1-进程的概念：" class="headerlink" title="3.1.1 进程的概念："></a>3.1.1 进程的概念：</h4><p><code>系统中正在运行的应用程序。</code></p>
<h4 id="3-1-2-进程的特点："><a href="#3-1-2-进程的特点：" class="headerlink" title="3.1.2 进程的特点："></a>3.1.2 进程的特点：</h4><p><code>每个进程都运行在其专用且受保护的内存空间，不同的进程之间相互独立，互不干扰。</code></p>
<h3 id="3-2-线程"><a href="#3-2-线程" class="headerlink" title="3.2 线程"></a>3.2 线程</h3><h4 id="3-2-1-线程的概念："><a href="#3-2-1-线程的概念：" class="headerlink" title="3.2.1 线程的概念："></a>3.2.1 线程的概念：</h4><p><code>线程是进程的执行任务的基本单元，一个进程的所有任务都是在线程中执行的。（每一个进程至少要有一条线程）。</code></p>
<h4 id="3-2-2-线程的特点："><a href="#3-2-2-线程的特点：" class="headerlink" title="3.2.2 线程的特点："></a>3.2.2 线程的特点：</h4><p><code>线程在执行任务的时候是按顺序执行的。如果要让一条线程执行多个任务，那么只能一个一个地并且按顺序执行这些任务。也就是说，在同一时间，一条线程只能执行一个任务。</code></p>
<p>我们可以通过Mac中的活动监视器查看进程和线程，下图！</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1442184-c62105f160632064.jpg" alt="活动监视器"></p>
<h2 id="4、多线程的概念及原理"><a href="#4、多线程的概念及原理" class="headerlink" title="4、多线程的概念及原理"></a>4、多线程的概念及原理</h2><h3 id="4-1-多线程概念："><a href="#4-1-多线程概念：" class="headerlink" title="4.1 多线程概念："></a>4.1 多线程概念：</h3><p><code>1个进程可以开启多条线程，多条线程可以同时执行不同的任务。</code></p>
<h3 id="4-2-多线程原理："><a href="#4-2-多线程原理：" class="headerlink" title="4.2 多线程原理："></a>4.2 多线程原理：</h3><p><img src="https://upload-images.jianshu.io/upload_images/1442184-12f342316d03e925.jpg" alt="多线程原理"></p>
<blockquote>
<p> <code>前提是在单核CPU的情况下，同一时间，CPU只能处理一条线程，也就是说只有一条线程在执行任务。多线程同时执行，那是不可能的！但是是CPU快速地在多条线程之间进行调度和切换执行任务。如果CPU调度线程的速度足够快，就会造成多条线程同时执行任务的”假象”，这种假象，就被美誉为：多线程!</code></p>
</blockquote>
<h2 id="5、多线程的优缺点和一个Tip"><a href="#5、多线程的优缺点和一个Tip" class="headerlink" title="5、多线程的优缺点和一个Tip"></a>5、多线程的优缺点和一个Tip</h2><h3 id="5-1-多线程的优点"><a href="#5-1-多线程的优点" class="headerlink" title="5.1 多线程的优点"></a>5.1 多线程的优点</h3><ul>
<li><code>可以适当提高程序的执行效率</code></li>
<li><code>也可以适当提高资源的利用率(CPU、内存利用率)</code></li>
</ul>
<h3 id="5-2-多线程的缺点"><a href="#5-2-多线程的缺点" class="headerlink" title="5.2 多线程的缺点"></a>5.2 多线程的缺点</h3><ul>
<li><code>开启一条线程需要占用一定的内存空间（默认情况下，每一条线程都占用512KB），如果开启大量的线程，会占用大量的内存空间，从而降低程序的性能。</code></li>
<li><code>线程越多，CPU在调度和切换线程上的开销就会越大。</code></li>
<li><code>线程数越多，程序的设计会越复杂。</code></li>
</ul>
<h3 id="5-3-Tip"><a href="#5-3-Tip" class="headerlink" title="5.3 Tip"></a>5.3 Tip</h3><ul>
<li><code>开启新的线程就会消耗资源，但是却可以提高用户体验。在保证良好的用户体验的前提下，可以适当地开线程，一般开3-6条。</code></li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/1442184-e7872d1d03c64413.jpg"></p>
<ul>
<li><code>开启一条新的线程，默认情况下，一条线程都是占用512KB，但是官方的文档里面给出的说明却不是，为了得出真相，下面做个小小的测试！</code></li>
</ul>
<p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        /** 操作主线程 */</span><br><span class="line">        NSLog(@&quot;主线程默认 %tu&quot;, [NSThread currentThread].stackSize / 1024);</span><br><span class="line">        // 设置主线程的stackSize</span><br><span class="line">        [NSThread currentThread].stackSize = 1024 * 1024;</span><br><span class="line">        NSLog(@&quot;主线程修改 %tu&quot;, [NSThread currentThread].stackSize / 1024);</span><br><span class="line">        </span><br><span class="line">        /** 操作子线程 */</span><br><span class="line">        NSThread *thread = [[NSThread alloc] init];</span><br><span class="line">        NSLog(@&quot;thread默认 %tu&quot;, thread.stackSize / 1024);</span><br><span class="line">        // 设置子线程的stackSize</span><br><span class="line">        thread.stackSize = 8 * 1024;</span><br><span class="line">        NSLog(@&quot;thread修改 %tu&quot;, thread.stackSize / 1024);</span><br><span class="line">        [thread start];</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>控制台</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2016-02-17 08:36:02.652 Test[609:110129] 主线程默认 512  </span><br><span class="line">2016-02-17 08:36:02.654 Test[609:110129] 主线程修改 1024  </span><br><span class="line">2016-02-17 08:36:02.654 Test[609:110129] thread默认 512  </span><br><span class="line">2016-02-17 08:36:02.654 Test[609:110129] thread修改 8</span><br></pre></td></tr></table></figure>


<blockquote>
<p><code>证明了，不管什么线程，默认都是512，最小为8.可能是官方文档没有及时更新吧！</code></p>
</blockquote>
<h2 id="6、主线程"><a href="#6、主线程" class="headerlink" title="6、主线程"></a>6、主线程</h2><h3 id="6-1-主线程的概念："><a href="#6-1-主线程的概念：" class="headerlink" title="6.1 主线程的概念："></a>6.1 主线程的概念：</h3><p><code>一个应用程序在启动运行后，系统会自动开启1条线程，这条称为”主线程”。</code></p>
<h3 id="6-2-主线程的作用："><a href="#6-2-主线程的作用：" class="headerlink" title="6.2 主线程的作用："></a>6.2 主线程的作用：</h3><p><code>主线程的作用主要用于处理UI界面刷新和UI时间！</code></p>
<h3 id="6-3-结论："><a href="#6-3-结论：" class="headerlink" title="6.3 结论："></a>6.3 结论：</h3><p> <code>主线程上不能执行耗时操作，这样会造成界面卡顿，给用户一种不好的体验。</code></p>
<h2 id="7、技术方案"><a href="#7、技术方案" class="headerlink" title="7、技术方案"></a>7、技术方案</h2><p><img src="https://upload-images.jianshu.io/upload_images/1442184-958d37ecd73c1caf.jpg" alt="解决方案"></p>
<hr>
<h1 id="二、Pthread"><a href="#二、Pthread" class="headerlink" title="二、Pthread"></a>二、Pthread</h1><h2 id="1、函数"><a href="#1、函数" class="headerlink" title="1、函数"></a></a>1、函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread_create(pthread_t *restrict, const pthread_attr_t *restrict, void _(_)(void *), void *restrict)</span><br></pre></td></tr></table></figure>


<h2 id="2、参数和返回值"><a href="#2、参数和返回值" class="headerlink" title="2、参数和返回值"></a>2、参数和返回值</h2><ul>
<li><p><code>pthread_t *restrict</code> 线程编号的地址</p>
</li>
<li><p><code>const pthread_attr_t *restrict</code> 线程的属性</p>
</li>
<li><p><code>void *(*)(void *)</code> 线程要执行的函数</p>
</li>
<li><p><code>int * </code>指向<code>int</code>类型的指针<code> void *</code> 指向任何类型的指针 有点类似OC中的<code>id</code></p>
</li>
<li><p><code>void *restrict </code>要执行的函数的参数</p>
</li>
<li><p>返回值<code>int</code>类型 0是成功 非0 是失败</p>
</li>
</ul>
<h2 id="3、使用"><a href="#3、使用" class="headerlink" title="3、使用"></a>3、使用</h2><p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"># import &lt;pthread/pthread.h&gt;</span><br><span class="line"></span><br><span class="line">void *demo(void *param) &#123;</span><br><span class="line">    NSString *name = (__bridge NSString *)(param);</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;hello %@ %@&quot;,name,[NSThread currentThread]);</span><br><span class="line">    return NULL;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        //创建子线程</span><br><span class="line">        pthread_t pthread; //线程编号</span><br><span class="line">        </span><br><span class="line">        NSString *test = @&quot;test&quot;;</span><br><span class="line">        int result =  pthread_create(&amp;pthread, NULL, demo, (__bridge void *)(test));</span><br><span class="line">        NSLog(@&quot;Began  %@&quot;,[NSThread currentThread]);</span><br><span class="line">        </span><br><span class="line">        if (result == 0) &#123;</span><br><span class="line">            NSLog(@&quot;成功&quot;);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            NSLog(@&quot;失败&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>控制台</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2016-02-16 22:00:57.401 Test[888:42585] Began &lt;NSThread: 0x100502d70&gt;&#123;number = 1, name = main&#125;  </span><br><span class="line">2016-02-16 22:00:57.403 Test[888:42615] hello test &lt;NSThread: 0x100102a30&gt;&#123;number = 2, name = (null)&#125;  </span><br><span class="line">2016-02-16 22:00:57.403 Test[888:42585] 成功</span><br></pre></td></tr></table></figure>


<blockquote>
<ul>
<li><code>__bridge 桥接</code>，把OC中的对象，传递给c语言的函数，使用<code>__bridge</code></li>
</ul>
</blockquote>
<hr>
<h1 id="三、NSThread"><a href="#三、NSThread" class="headerlink" title="三、NSThread"></a>三、NSThread</h1><h2 id="1、创建一个新的线程"><a href="#1、创建一个新的线程" class="headerlink" title="1、创建一个新的线程"></a>1、创建一个新的线程</h2><ul>
<li><h3 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h3></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(demo) object:nil];</span><br></pre></td></tr></table></figure>

<ul>
<li><h3 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h3></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[NSThread detachNewThreadSelector:@selector(demo) toTarget:self withObject:nil];</span><br></pre></td></tr></table></figure>


<ul>
<li><h3 id="方式三"><a href="#方式三" class="headerlink" title="方式三"></a>方式三</h3></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self performSelectorInBackground:@selector(demo) withObject:nil];</span><br></pre></td></tr></table></figure>


<h2 id="2、线程的状态"><a href="#2、线程的状态" class="headerlink" title="2、线程的状态"></a>2、线程的状态</h2><h3 id="线程状态分为五种"><a href="#线程状态分为五种" class="headerlink" title="线程状态分为五种"></a>线程状态分为五种</h3><ul>
<li><p>创建 New</p>
</li>
<li><p>就绪 Runnable</p>
</li>
<li><p>运行 Running</p>
<ul>
<li><code> (void)start;</code></li>
</ul>
</li>
<li><p>阻塞（暂停） Blocked</p>
<ul>
<li><code>(void)sleepUntilDate:(NSDate *)date;</code></li>
<li><code>(void)sleepForTimeInterval:(NSTimeInterval)ti;</code></li>
</ul>
</li>
<li><p>死亡 Dead</p>
<ul>
<li><code>(void)exit;</code></li>
</ul>
</li>
</ul>
<h2 id="3、线程的属性"><a href="#3、线程的属性" class="headerlink" title="3、线程的属性"></a>3、线程的属性</h2><p><strong><code>线程有两个重要的属性：名称和优先级</code></strong></p>
<h3 id="3-1-名称-name"><a href="#3-1-名称-name" class="headerlink" title="3.1 名称 name"></a>3.1 名称 name</h3><p><strong>设置线程名用于记录线程，在出现异常时可以DeBug</strong></p>
<h3 id="3-2-优先级，也叫做“服务质量”。threadPriority，取值0到1"><a href="#3-2-优先级，也叫做“服务质量”。threadPriority，取值0到1" class="headerlink" title="3.2 优先级，也叫做“服务质量”。threadPriority，取值0到1."></a>3.2 优先级，也叫做“服务质量”。<code>threadPriority</code>，取值0到1.</h3><p><strong>优先级或者服务质量高的，可以优先调用，只是说会优先调用，但是不是百分之百的优先调用，这里存在一个概率问题，内核里的算法调度线程的时候，只是把优先级作为一个考虑因素，还有很多个因数会决定哪个线程优先调用。这点得注意注意！！！</strong></p>
<p>下面是测试代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">    //新建状态</span><br><span class="line">    NSThread *test1 = [[NSThread alloc] initWithTarget:self selector:@selector(demo) object:nil];</span><br><span class="line">    test1.name = @&quot;test1&quot;;</span><br><span class="line">    //线程的优先级</span><br><span class="line">    test1.threadPriority = 1.0;</span><br><span class="line">    //就绪状态</span><br><span class="line">    [test1 start];</span><br><span class="line">    </span><br><span class="line">    //新建状态</span><br><span class="line">    NSThread *test2= [[NSThread alloc] initWithTarget:self selector:@selector(demo) object:nil];</span><br><span class="line">    test2.name = @&quot;test2&quot;;</span><br><span class="line">    test2.threadPriority = 0;</span><br><span class="line">    //就绪状态</span><br><span class="line">    [test2 start];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//线程执行完成之后会自动销毁</span><br><span class="line"></span><br><span class="line">- (void)demo &#123;</span><br><span class="line">    for (int i = 0; i &lt; 20; i++) &#123;</span><br><span class="line">        NSLog(@&quot;%d--%@&quot;,i,[NSThread currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>控制台</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">2016-02-16 22:43:28.182 05-线程状态[1241:78688] 0--&lt;NSThread: 0x7fead2017f30&gt;&#123;number = 2, name = test1&#125;  </span><br><span class="line">2016-02-16 22:43:28.182 05-线程状态[1241:78689] 0--&lt;NSThread: 0x7fead050a250&gt;&#123;number = 3, name = test2&#125;  </span><br><span class="line">2016-02-16 22:43:28.182 05-线程状态[1241:78688] 1--&lt;NSThread: 0x7fead2017f30&gt;&#123;number = 2, name = test1&#125;  </span><br><span class="line">2016-02-16 22:43:28.182 05-线程状态[1241:78688] 2--&lt;NSThread: 0x7fead2017f30&gt;&#123;number = 2, name = test1&#125;  </span><br><span class="line">2016-02-16 22:43:28.182 05-线程状态[1241:78689] 1--&lt;NSThread: 0x7fead050a250&gt;&#123;number = 3, name = test2&#125;  </span><br><span class="line">2016-02-16 22:43:28.183 05-线程状态[1241:78688] 3--&lt;NSThread: 0x7fead2017f30&gt;&#123;number = 2, name = test1&#125;  </span><br><span class="line">2016-02-16 22:43:28.183 05-线程状态[1241:78689] 2--&lt;NSThread: 0x7fead050a250&gt;&#123;number = 3, name = test2&#125;  </span><br><span class="line">2016-02-16 22:43:28.183 05-线程状态[1241:78688] 4--&lt;NSThread: 0x7fead2017f30&gt;&#123;number = 2, name = test1&#125;  </span><br><span class="line">2016-02-16 22:43:28.183 05-线程状态[1241:78688] 5--&lt;NSThread: 0x7fead2017f30&gt;&#123;number = 2, name = test1&#125;  </span><br><span class="line">2016-02-16 22:43:28.183 05-线程状态[1241:78689] 3--&lt;NSThread: 0x7fead050a250&gt;&#123;number = 3, name = test2&#125;  </span><br><span class="line">2016-02-16 22:43:28.183 05-线程状态[1241:78688] 6--&lt;NSThread: 0x7fead2017f30&gt;&#123;number = 2, name = test1&#125;  </span><br><span class="line">2016-02-16 22:43:28.183 05-线程状态[1241:78688] 7--&lt;NSThread: 0x7fead2017f30&gt;&#123;number = 2, name = test1&#125;  </span><br><span class="line">2016-02-16 22:43:28.183 05-线程状态[1241:78689] 4--&lt;NSThread: 0x7fead050a250&gt;&#123;number = 3, name = test2&#125;  </span><br><span class="line">2016-02-16 22:43:28.183 05-线程状态[1241:78688] 8--&lt;NSThread: 0x7fead2017f30&gt;&#123;number = 2, name = test1&#125;  </span><br><span class="line">2016-02-16 22:43:28.184 05-线程状态[1241:78688] 9--&lt;NSThread: 0x7fead2017f30&gt;&#123;number = 2, name = test1&#125;  </span><br><span class="line">2016-02-16 22:43:28.184 05-线程状态[1241:78688] 10--&lt;NSThread: 0x7fead2017f30&gt;&#123;number = 2, name = test1&#125;  </span><br><span class="line">2016-02-16 22:43:28.184 05-线程状态[1241:78689] 5--&lt;NSThread: 0x7fead050a250&gt;&#123;number = 3, name = test2&#125;  </span><br><span class="line">2016-02-16 22:43:28.184 05-线程状态[1241:78688] 11--&lt;NSThread: 0x7fead2017f30&gt;&#123;number = 2, name = test1&#125;  </span><br><span class="line">2016-02-16 22:43:28.184 05-线程状态[1241:78689] 6--&lt;NSThread: 0x7fead050a250&gt;&#123;number = 3, name = test2&#125;  </span><br><span class="line">2016-02-16 22:43:28.184 05-线程状态[1241:78688] 12--&lt;NSThread: 0x7fead2017f30&gt;&#123;number = 2, name = test1&#125;  </span><br><span class="line">2016-02-16 22:43:28.184 05-线程状态[1241:78688] 13--&lt;NSThread: 0x7fead2017f30&gt;&#123;number = 2, name = test1&#125;  </span><br><span class="line">2016-02-16 22:43:28.184 05-线程状态[1241:78689] 7--&lt;NSThread: 0x7fead050a250&gt;&#123;number = 3, name = test2&#125;  </span><br><span class="line">2016-02-16 22:43:28.184 05-线程状态[1241:78688] 14--&lt;NSThread: 0x7fead2017f30&gt;&#123;number = 2, name = test1&#125;  </span><br><span class="line">2016-02-16 22:43:28.184 05-线程状态[1241:78688] 15--&lt;NSThread: 0x7fead2017f30&gt;&#123;number = 2, name = test1&#125;  </span><br><span class="line">2016-02-16 22:43:28.185 05-线程状态[1241:78688] 16--&lt;NSThread: 0x7fead2017f30&gt;&#123;number = 2, name = test1&#125;  </span><br><span class="line">2016-02-16 22:43:28.184 05-线程状态[1241:78689] 8--&lt;NSThread: 0x7fead050a250&gt;&#123;number = 3, name = test2&#125;  </span><br><span class="line">2016-02-16 22:43:28.185 05-线程状态[1241:78688] 17--&lt;NSThread: 0x7fead2017f30&gt;&#123;number = 2, name = test1&#125;  </span><br><span class="line">2016-02-16 22:43:28.185 05-线程状态[1241:78688] 18--&lt;NSThread: 0x7fead2017f30&gt;&#123;number = 2, name = test1&#125;  </span><br><span class="line">2016-02-16 22:43:28.185 05-线程状态[1241:78689] 9--&lt;NSThread: 0x7fead050a250&gt;&#123;number = 3, name = test2&#125;  </span><br><span class="line">2016-02-16 22:43:28.185 05-线程状态[1241:78688] 19--&lt;NSThread: 0x7fead2017f30&gt;&#123;number = 2, name = test1&#125;  </span><br><span class="line">2016-02-16 22:43:28.185 05-线程状态[1241:78689] 10--&lt;NSThread: 0x7fead050a250&gt;&#123;number = 3, name = test2&#125;  </span><br><span class="line">2016-02-16 22:43:28.186 05-线程状态[1241:78689] 11--&lt;NSThread: 0x7fead050a250&gt;&#123;number = 3, name = test2&#125;  </span><br><span class="line">2016-02-16 22:43:28.186 05-线程状态[1241:78689] 12--&lt;NSThread: 0x7fead050a250&gt;&#123;number = 3, name = test2&#125;  </span><br><span class="line">2016-02-16 22:43:28.186 05-线程状态[1241:78689] 13--&lt;NSThread: 0x7fead050a250&gt;&#123;number = 3, name = test2&#125;  </span><br><span class="line">2016-02-16 22:43:28.186 05-线程状态[1241:78689] 14--&lt;NSThread: 0x7fead050a250&gt;&#123;number = 3, name = test2&#125;  </span><br><span class="line">2016-02-16 22:43:28.187 05-线程状态[1241:78689] 15--&lt;NSThread: 0x7fead050a250&gt;&#123;number = 3, name = test2&#125;  </span><br><span class="line">2016-02-16 22:43:28.187 05-线程状态[1241:78689] 16--&lt;NSThread: 0x7fead050a250&gt;&#123;number = 3, name = test2&#125;  </span><br><span class="line">2016-02-16 22:43:28.187 05-线程状态[1241:78689] 17--&lt;NSThread: 0x7fead050a250&gt;&#123;number = 3, name = test2&#125;  </span><br><span class="line">2016-02-16 22:43:28.187 05-线程状态[1241:78689] 18--&lt;NSThread: 0x7fead050a250&gt;&#123;number = 3, name = test2&#125;  </span><br><span class="line">2016-02-16 22:43:28.187 05-线程状态[1241:78689] 19--&lt;NSThread: 0x7fead050a250&gt;&#123;number = 3, name = test2&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>结论：优先级高，不一定先执行，只能说明先执行的概率要大一些！！！</code></p>
</blockquote>
<hr>
<h1 id="四、互斥锁"><a href="#四、互斥锁" class="headerlink" title="四、互斥锁"></a>四、互斥锁</h1><h2 id="1、访问共享资源引入问题！"><a href="#1、访问共享资源引入问题！" class="headerlink" title="1、访问共享资源引入问题！"></a>1、访问共享资源引入问题！</h2><h3 id="1-1-问题？"><a href="#1-1-问题？" class="headerlink" title="1.1 问题？"></a>1.1 问题？</h3><p> <code>不同的线程要访问共享的资源，而且对共享的资源做操作，由于上面结论得出服务质量和优先级不能决定线程执行的先后顺序，那么问题来了，一个线程对共享资源做了修改，而另外一个线程拿到的是未被修改之前资源，这是这个线程也对该资源做了修改，现在请问，两个线程都对该资源做了不同的修改，那么这个修改应该算谁的？！？！这就是问题所在！！！</code></p>
<h3 id="1-2-问题分析"><a href="#1-2-问题分析" class="headerlink" title="1.2 问题分析"></a>1.2 问题分析</h3><p><img src="https://upload-images.jianshu.io/upload_images/1442184-988b8cc8226a4ebd.jpg" alt="image"></p>
<h3 id="1-3-问题解决"><a href="#1-3-问题解决" class="headerlink" title="1.3 问题解决"></a>1.3 问题解决</h3><p><img src="https://upload-images.jianshu.io/upload_images/1442184-01f1a111e45054ac.jpg" alt="image"></p>
<p> <code>解决方案很简单，就是用一把锁锁住共享资源，等待线程1对其操作完毕后再打开，让线程2来执行，这就是传说中的互斥锁</code>！！！</p>
<h2 id="2、互斥锁介绍"><a href="#2、互斥锁介绍" class="headerlink" title="2、互斥锁介绍"></a><a id="2、互斥锁介绍"></a>2、互斥锁介绍</h2><h3 id="2-1-互斥锁代码"><a href="#2-1-互斥锁代码" class="headerlink" title="2.1 互斥锁代码"></a>2.1 互斥锁代码</h3><p><code>@synchronized(锁对象) &#123; 需要锁定的代码 &#125;</code></p>
<h3 id="2-2-互斥锁的作用"><a href="#2-2-互斥锁的作用" class="headerlink" title="2.2 互斥锁的作用"></a>2.2 互斥锁的作用</h3><p><code>可以防止因多线程执行顺序不定导致的抢夺资源造成的数据安全的问题</code></p>
<h3 id="2-3-真相："><a href="#2-3-真相：" class="headerlink" title="2.3 真相："></a>2.3 真相：</h3><p><code>互斥锁其实就是同步的意思，也就是按顺序执行！</code></p>
<h2 id="3、互斥锁原理"><a href="#3、互斥锁原理" class="headerlink" title="3、互斥锁原理"></a>3、互斥锁原理</h2><p><code>每个NSObject对象内部都有一把锁，当线程要进入synchronized到对象的时候就要判断，锁是否被打开，如果打开，进入执行，如果锁住，继续等待，这就是互斥锁的原理！</code></p>
<h2 id="4、互斥锁和自旋锁"><a href="#4、互斥锁和自旋锁" class="headerlink" title="4、互斥锁和自旋锁"></a>4、互斥锁和自旋锁</h2><p><code>自旋锁就是atomic！</code></p>
<h3 id="4-1-原子属性和非原子属性（nonatomic-和-atomic）"><a href="#4-1-原子属性和非原子属性（nonatomic-和-atomic）" class="headerlink" title="4.1 原子属性和非原子属性（nonatomic 和 atomic）"></a>4.1 原子属性和非原子属性（<code>nonatomic</code> 和 <code>atomic</code>）</h3><ul>
<li><code>nonatomic</code>:非原子属性，不会为 setter 方法加锁。</li>
<li><code>atomic</code>: 原子属性，为 setter 方法加锁(默认就是atomic)。</li>
<li>通过给 setter 加锁，可以保证同一时间只有一个线程能够执行写入操作(setter)，但是同一时间允许多个线程执行读取操作(getter)。<code>atomic</code>本身就有一把自旋锁。<br>这个特点叫做”单写多读”: 单个线程写入，多个线程读取。</li>
<li><code> atomic</code> 只能保证写入数据的时候是安全的，但不能保证同时读写的时候是安全的。所以，不常使用！</li>
</ul>
<h3 id="4-2-nonatomic-和-atomic-的对比"><a href="#4-2-nonatomic-和-atomic-的对比" class="headerlink" title="4.2 nonatomic 和 atomic 的对比"></a>4.2 <code>nonatomic</code> 和 <code>atomic</code> 的对比</h3><ul>
<li><p><code>atomic</code>：线程安全(执行setter方法的时候)，需要消耗大量的资源。</p>
</li>
<li><p><code>nonatomic</code>：非线程安全，适合内存小的移动设备。</p>
</li>
</ul>
<h3 id="4-3-互斥锁和自旋锁的区别"><a href="#4-3-互斥锁和自旋锁的区别" class="headerlink" title="4.3 互斥锁和自旋锁的区别"></a>4.3 互斥锁和自旋锁的区别</h3><h4 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h4><p><code>如果发现其它线程正在执行锁定代码，线程会进入休眠(阻塞状态)，等其它线程时间片到了打开锁后，线程就会被唤醒(执行)。</code></p>
<h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><p><code>如果发现有其它线程正在执行锁定代码，线程会以死循环的方式，一直等待锁定的代码执行完成。</code></p>
<hr>
<h1 id="五、GCD"><a href="#五、GCD" class="headerlink" title="五、GCD"></a>五、GCD</h1><h2 id="1、GCD介绍"><a href="#1、GCD介绍" class="headerlink" title="1、GCD介绍"></a>1、GCD介绍</h2><blockquote>
<p>全称<code>Grand Central Dispatch</code>,可翻译为”牛逼的中枢调度器”</p>
<p>纯C语言开发，是苹果公司为多核的并行运算提出的解决方案，会自动利用更多的CPU内核（比如双核、四核），可以自动管理线程的生命周期（创建线程、调度任务、销毁线程）。</p>
</blockquote>
<h2 id="2、GCD的两个核心"><a href="#2、GCD的两个核心" class="headerlink" title="2、GCD的两个核心"></a><a id="2、GCD的两个核心"></a>2、GCD的两个核心</h2><h3 id="2-1-任务"><a href="#2-1-任务" class="headerlink" title="2.1 任务"></a>2.1 任务</h3><ul>
<li>执行的操作,在GCD中，任务是通过 block来封装的。并且任务的block没有参数也没有返回值。</li>
</ul>
<h3 id="2-2-队列"><a href="#2-2-队列" class="headerlink" title="2.2 队列"></a>2.2 队列</h3><ul>
<li>存放任务</li>
</ul>
<h4 id="包括"><a href="#包括" class="headerlink" title="包括"></a>包括</h4><ul>
<li>串行队列</li>
<li>并发队列</li>
<li>主队列</li>
<li>全局队列</li>
</ul>
<p>队列的类型</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1442184-aea71e89d504e051.jpg" alt="image"></p>
<h2 id="3、函数"><a href="#3、函数" class="headerlink" title="3、函数"></a>3、函数</h2><h3 id="3-1-GCD函数"><a href="#3-1-GCD函数" class="headerlink" title="3.1 GCD函数"></a>3.1 GCD函数</h3><h4 id="3-1-1-同步-dispatch-sync"><a href="#3-1-1-同步-dispatch-sync" class="headerlink" title="3.1.1 同步 dispatch_sync"></a>3.1.1 同步 <code>dispatch_sync</code></h4><h5 id="同步：任务会在当前线程执行，因为同步函数不具备开新线程的能力。"><a href="#同步：任务会在当前线程执行，因为同步函数不具备开新线程的能力。" class="headerlink" title="同步：任务会在当前线程执行，因为同步函数不具备开新线程的能力。"></a>同步：任务会在当前线程执行，因为同步函数不具备开新线程的能力。</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);</span><br></pre></td></tr></table></figure>


<h4 id="3-1-2-异步-dispatch-async"><a href="#3-1-2-异步-dispatch-async" class="headerlink" title="3.1.2 异步 dispatch_async"></a>3.1.2 异步 <code>dispatch_async</code></h4><h5 id="异步：任务会在子线程执行，因为异步函数具备开新线程的能力。"><a href="#异步：任务会在子线程执行，因为异步函数具备开新线程的能力。" class="headerlink" title="异步：任务会在子线程执行，因为异步函数具备开新线程的能力。"></a>异步：任务会在子线程执行，因为异步函数具备开新线程的能力。</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void dispatch_async(dispatch_queue_t queue, dispatch_block_t block);</span><br></pre></td></tr></table></figure>


<h3 id="3-2-GCD使用步骤"><a href="#3-2-GCD使用步骤" class="headerlink" title="3.2 GCD使用步骤:"></a>3.2 GCD使用步骤:</h3><ul>
<li>创建队列，或则获取队列</li>
<li>创建任务</li>
<li>将任务添加到队列中</li>
<li>GCD会自动将队列中的任务取出，放到对应的线程中执行</li>
<li>任务取出遵循队列的FIFO原则：先进先出，后进后出</li>
</ul>
<p>示例代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 1\. 获取全局队列</span><br><span class="line"></span><br><span class="line">dispatch_queue_t queue = dispatch_get_global_queue(0, 0);</span><br><span class="line">// 2\. 创建任务</span><br><span class="line">dispatch_block_t task = ^ &#123;</span><br><span class="line">    NSLog(@&quot;hello %@&quot;, [NSThread currentThread]);</span><br><span class="line">&#125;;</span><br><span class="line">// 3\. 将任务添加到队列，并且指定执行任务的函数</span><br><span class="line">dispatch_async(queue, task);</span><br></pre></td></tr></table></figure>
<p> 通常写成一句代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;  </span><br><span class="line">    NSLog(@&quot;hello %@&quot;, [NSThread currentThread]);  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<h2 id="4、串行队列和并发队列"><a href="#4、串行队列和并发队列" class="headerlink" title="4、串行队列和并发队列"></a>4、串行队列和并发队列</h2><h3 id="4-1-串行队列-Serial-Dispatch-Queue"><a href="#4-1-串行队列-Serial-Dispatch-Queue" class="headerlink" title="4.1 串行队列 Serial Dispatch Queue"></a>4.1 串行队列 <code>Serial Dispatch Queue</code></h3><h4 id="4-1-1-特点"><a href="#4-1-1-特点" class="headerlink" title="4.1.1 特点"></a>4.1.1 特点</h4><ul>
<li><code>先进先出，按照顺序执行,并且一次只能调用一个任务</code></li>
<li><code>无论队列中所指定的执行任务的函数是同步还是异步，都必须等待前一个任务执行完毕才可以调用后面的人</code></li>
</ul>
<h4 id="4-1-2-创建一个串行队列"><a href="#4-1-2-创建一个串行队列" class="headerlink" title="4.1.2 创建一个串行队列"></a>4.1.2 创建一个串行队列</h4><ul>
<li>方法一</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;test&quot;, DISPATCH_QUEUE_SERIAL);</span><br></pre></td></tr></table></figure>


<ul>
<li>方法二</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;test&quot;, NULL);</span><br></pre></td></tr></table></figure>


<h4 id="4-1-3-串行队列，同步执行"><a href="#4-1-3-串行队列，同步执行" class="headerlink" title="4.1.3 串行队列，同步执行"></a>4.1.3 串行队列，同步执行</h4><p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 1、创建串行队列</span><br><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;test&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">// 2、将任务添加到队列，并且指定同步执行</span><br><span class="line">for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;%@--%d&quot;,[NSThread currentThread],i);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">2016-02-25 16:31:07.849 test[1924:376468] &lt;NSThread: 0x7ff040404370&gt;&#123;number = 1, name = main&#125;--0  </span><br><span class="line">2016-02-25 16:31:07.849 test[1924:376468] &lt;NSThread: 0x7ff040404370&gt;&#123;number = 1, name = main&#125;--1  </span><br><span class="line">2016-02-25 16:31:07.849 test[1924:376468] &lt;NSThread: 0x7ff040404370&gt;&#123;number = 1, name = main&#125;--2  </span><br><span class="line">2016-02-25 16:31:07.849 test[1924:376468] &lt;NSThread: 0x7ff040404370&gt;&#123;number = 1, name = main&#125;--3  </span><br><span class="line">2016-02-25 16:31:07.849 test[1924:376468] &lt;NSThread: 0x7ff040404370&gt;&#123;number = 1, name = main&#125;--4  </span><br><span class="line">2016-02-25 16:31:07.849 test[1924:376468] &lt;NSThread: 0x7ff040404370&gt;&#123;number = 1, name = main&#125;--5  </span><br><span class="line">2016-02-25 16:31:07.850 test[1924:376468] &lt;NSThread: 0x7ff040404370&gt;&#123;number = 1, name = main&#125;--6  </span><br><span class="line">2016-02-25 16:31:07.850 test[1924:376468] &lt;NSThread: 0x7ff040404370&gt;&#123;number = 1, name = main&#125;--7  </span><br><span class="line">2016-02-25 16:31:07.850 test[1924:376468] &lt;NSThread: 0x7ff040404370&gt;&#123;number = 1, name = main&#125;--8  </span><br><span class="line">2016-02-25 16:31:07.850 test[1924:376468] &lt;NSThread: 0x7ff040404370&gt;&#123;number = 1, name = main&#125;--9</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>结论：串行队列，同步执行，不开新线程，按顺序执行</code></p>
</blockquote>
<h4 id="4-1-4-串行队列，异步执行"><a href="#4-1-4-串行队列，异步执行" class="headerlink" title="4.1.4 串行队列，异步执行"></a>4.1.4 串行队列，异步执行</h4><p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 1、创建串行队列</span><br><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;test&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">// 2、将任务添加到队列，并且指定同步执行</span><br><span class="line">for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;%@--%d&quot;,[NSThread currentThread],i);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">2016-02-25 17:08:32.167 test[1959:391722] &lt;NSThread: 0x7fbb98d24fa0&gt;&#123;number = 2, name = (null)&#125;--0  </span><br><span class="line">2016-02-25 17:08:32.168 test[1959:391722] &lt;NSThread: 0x7fbb98d24fa0&gt;&#123;number = 2, name = (null)&#125;--1  </span><br><span class="line">2016-02-25 17:08:32.168 test[1959:391722] &lt;NSThread: 0x7fbb98d24fa0&gt;&#123;number = 2, name = (null)&#125;--2  </span><br><span class="line">2016-02-25 17:08:32.168 test[1959:391722] &lt;NSThread: 0x7fbb98d24fa0&gt;&#123;number = 2, name = (null)&#125;--3  </span><br><span class="line">2016-02-25 17:08:32.168 test[1959:391722] &lt;NSThread: 0x7fbb98d24fa0&gt;&#123;number = 2, name = (null)&#125;--4  </span><br><span class="line">2016-02-25 17:08:32.168 test[1959:391722] &lt;NSThread: 0x7fbb98d24fa0&gt;&#123;number = 2, name = (null)&#125;--5  </span><br><span class="line">2016-02-25 17:08:32.169 test[1959:391722] &lt;NSThread: 0x7fbb98d24fa0&gt;&#123;number = 2, name = (null)&#125;--6  </span><br><span class="line">2016-02-25 17:08:32.169 test[1959:391722] &lt;NSThread: 0x7fbb98d24fa0&gt;&#123;number = 2, name = (null)&#125;--7  </span><br><span class="line">2016-02-25 17:08:32.169 test[1959:391722] &lt;NSThread: 0x7fbb98d24fa0&gt;&#123;number = 2, name = (null)&#125;--8  </span><br><span class="line">2016-02-25 17:08:32.169 test[1959:391722] &lt;NSThread: 0x7fbb98d24fa0&gt;&#123;number = 2, name = (null)&#125;--9</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>结论：串行队列，异步执行，开启一条新的线程，按顺序执行</code></p>
</blockquote>
<h3 id="4-2-并发队列-Concurrent-Dispatch-Queue"><a href="#4-2-并发队列-Concurrent-Dispatch-Queue" class="headerlink" title="4.2 并发队列 Concurrent Dispatch Queue"></a>4.2 并发队列 <code>Concurrent Dispatch Queue</code></h3><h4 id="4-2-1-特点"><a href="#4-2-1-特点" class="headerlink" title="4.2.1 特点"></a>4.2.1 特点</h4><ul>
<li>并发同时调度队列中的任务去执行</li>
<li>如果当前调度的任务是同步执行的，会等待当前任务执行完毕后，再调度后续的任务</li>
<li>如果当前调度的任务是异步执行的，同时底层线程池有可用的线程资源，就不会等待当前任务，直接调度任务到新线程去执行。</li>
</ul>
<h4 id="4-2-2-创建并发队列"><a href="#4-2-2-创建并发队列" class="headerlink" title="4.2.2 创建并发队列"></a>4.2.2 创建并发队列</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t q = dispatch_queue_create(&quot;test&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br></pre></td></tr></table></figure>


<h4 id="4-2-3-并发队列，同步执行"><a href="#4-2-3-并发队列，同步执行" class="headerlink" title="4.2.3 并发队列，同步执行"></a>4.2.3 并发队列，同步执行</h4><p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 1\. 创建并发队列</span><br><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;test&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">// 2\. 将任务添加到队列, 并且指定同步执行</span><br><span class="line">for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;%@ %d&quot;, [NSThread currentThread], i);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">2016-02-25 17:18:38.039 test[1979:399667] &lt;NSThread: 0x7ffef86024b0&gt;&#123;number = 1, name = main&#125; 0  </span><br><span class="line">2016-02-25 17:18:38.040 test[1979:399667] &lt;NSThread: 0x7ffef86024b0&gt;&#123;number = 1, name = main&#125; 1  </span><br><span class="line">2016-02-25 17:18:38.040 test[1979:399667] &lt;NSThread: 0x7ffef86024b0&gt;&#123;number = 1, name = main&#125; 2  </span><br><span class="line">2016-02-25 17:18:38.040 test[1979:399667] &lt;NSThread: 0x7ffef86024b0&gt;&#123;number = 1, name = main&#125; 3  </span><br><span class="line">2016-02-25 17:18:38.040 test[1979:399667] &lt;NSThread: 0x7ffef86024b0&gt;&#123;number = 1, name = main&#125; 4  </span><br><span class="line">2016-02-25 17:18:38.040 test[1979:399667] &lt;NSThread: 0x7ffef86024b0&gt;&#123;number = 1, name = main&#125; 5  </span><br><span class="line">2016-02-25 17:18:38.040 test[1979:399667] &lt;NSThread: 0x7ffef86024b0&gt;&#123;number = 1, name = main&#125; 6  </span><br><span class="line">2016-02-25 17:18:38.040 test[1979:399667] &lt;NSThread: 0x7ffef86024b0&gt;&#123;number = 1, name = main&#125; 7  </span><br><span class="line">2016-02-25 17:18:38.040 test[1979:399667] &lt;NSThread: 0x7ffef86024b0&gt;&#123;number = 1, name = main&#125; 8  </span><br><span class="line">2016-02-25 17:18:38.041 test[1979:399667] &lt;NSThread: 0x7ffef86024b0&gt;&#123;number = 1, name = main&#125; 9</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>结论:并发队列，同步执行，不开线程，顺序执行</code></p>
</blockquote>
<h4 id="4-2-4-并发队列，异步执行"><a href="#4-2-4-并发队列，异步执行" class="headerlink" title="4.2.4 并发队列，异步执行"></a>4.2.4 并发队列，异步执行</h4><p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 1\. 创建并发队列</span><br><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;test&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">// 2\. 将任务添加到队列, 并且指定同步执行</span><br><span class="line">for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;%@ %d&quot;, [NSThread currentThread], i);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">2016-02-25 17:22:59.357 test[1992:403694] &lt;NSThread: 0x7fe531c1a9b0&gt;&#123;number = 7, name = (null)&#125; 6  </span><br><span class="line">2016-02-25 17:22:59.356 test[1992:403684] &lt;NSThread: 0x7fe531d18fa0&gt;&#123;number = 3, name = (null)&#125; 1  </span><br><span class="line">2016-02-25 17:22:59.356 test[1992:403689] &lt;NSThread: 0x7fe534300610&gt;&#123;number = 5, name = (null)&#125; 3  </span><br><span class="line">2016-02-25 17:22:59.356 test[1992:403683] &lt;NSThread: 0x7fe531e94d80&gt;&#123;number = 2, name = (null)&#125; 0  </span><br><span class="line">2016-02-25 17:22:59.356 test[1992:403692] &lt;NSThread: 0x7fe531e9df80&gt;&#123;number = 6, name = (null)&#125; 4  </span><br><span class="line">2016-02-25 17:22:59.356 test[1992:403693] &lt;NSThread: 0x7fe531d18f40&gt;&#123;number = 8, name = (null)&#125; 5  </span><br><span class="line">2016-02-25 17:22:59.356 test[1992:403695] &lt;NSThread: 0x7fe5343015e0&gt;&#123;number = 9, name = (null)&#125; 7  </span><br><span class="line">2016-02-25 17:22:59.357 test[1992:403688] &lt;NSThread: 0x7fe531c16e30&gt;&#123;number = 4, name = (null)&#125; 2  </span><br><span class="line">2016-02-25 17:22:59.357 test[1992:403694] &lt;NSThread: 0x7fe531c1a9b0&gt;&#123;number = 7, name = (null)&#125; 9  </span><br><span class="line">2016-02-25 17:22:59.357 test[1992:403696] &lt;NSThread: 0x7fe531c237a0&gt;&#123;number = 10, name = (null)&#125; 8</span><br></pre></td></tr></table></figure>


<blockquote>
<p><code>结论：开启足够多的线程，不按照顺序执行CPU在调度的时候以最高效的方式调度和执行任务，所以会开启多条线程，因为并发，执行顺序不一定</code></p>
</blockquote>
<h2 id="5、主队列"><a href="#5、主队列" class="headerlink" title="5、主队列"></a>5、主队列</h2><h3 id="5-1-主队列"><a href="#5-1-主队列" class="headerlink" title="5.1 主队列"></a>5.1 主队列</h3><ul>
<li>主队列是系统提供的，无需自己创建，可以通过<code>dispatch_get_main_queue()</code>函数来获取。</li>
</ul>
<h3 id="5-2-特点"><a href="#5-2-特点" class="headerlink" title="5.2 特点"></a>5.2 特点</h3><ul>
<li>添加到主队列的任务只能由主线程来执行。</li>
<li>先进先出的，只有当主线程的代码执行完毕后，主队列才会调度任务到主线程执行</li>
</ul>
<h3 id="5-3-主队列-异步执行"><a href="#5-3-主队列-异步执行" class="headerlink" title="5.3 主队列 异步执行"></a>5.3 主队列 异步执行</h3><p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 1\. 获取主队列</span><br><span class="line">dispatch_queue_t q = dispatch_get_main_queue();</span><br><span class="line">// 2\. 将任务添加到主队列, 并且指定异步执行</span><br><span class="line">for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    dispatch_async(q, ^&#123;</span><br><span class="line">        NSLog(@&quot;%@ %d&quot;, [NSThread currentThread], i);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">// 先执行完这句代码, 才会执行主队列中的任务</span><br><span class="line">NSLog(@&quot;hello %@&quot;, [NSThread currentThread]);</span><br></pre></td></tr></table></figure>

<p>打印</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">2016-02-25 21:10:43.293 test[773:786816] hello &lt;NSThread: 0x7ff158c05940&gt;&#123;number = 1, name = main&#125;  </span><br><span class="line">2016-02-25 21:10:43.295 test[773:786816] &lt;NSThread: 0x7ff158c05940&gt;&#123;number = 1, name = main&#125; 0  </span><br><span class="line">2016-02-25 21:10:43.295 test[773:786816] &lt;NSThread: 0x7ff158c05940&gt;&#123;number = 1, name = main&#125; 1  </span><br><span class="line">2016-02-25 21:10:43.296 test[773:786816] &lt;NSThread: 0x7ff158c05940&gt;&#123;number = 1, name = main&#125; 2  </span><br><span class="line">2016-02-25 21:10:43.296 test[773:786816] &lt;NSThread: 0x7ff158c05940&gt;&#123;number = 1, name = main&#125; 3  </span><br><span class="line">2016-02-25 21:10:43.296 test[773:786816] &lt;NSThread: 0x7ff158c05940&gt;&#123;number = 1, name = main&#125; 4  </span><br><span class="line">2016-02-25 21:10:43.296 test[773:786816] &lt;NSThread: 0x7ff158c05940&gt;&#123;number = 1, name = main&#125; 5  </span><br><span class="line">2016-02-25 21:10:43.296 test[773:786816] &lt;NSThread: 0x7ff158c05940&gt;&#123;number = 1, name = main&#125; 6  </span><br><span class="line">2016-02-25 21:10:43.296 test[773:786816] &lt;NSThread: 0x7ff158c05940&gt;&#123;number = 1, name = main&#125; 7  </span><br><span class="line">2016-02-25 21:10:43.296 test[773:786816] &lt;NSThread: 0x7ff158c05940&gt;&#123;number = 1, name = main&#125; 8  </span><br><span class="line">2016-02-25 21:10:43.296 test[773:786816] &lt;NSThread: 0x7ff158c05940&gt;&#123;number = 1, name = main&#125; 9</span><br></pre></td></tr></table></figure>


<p>打印结果得出的一些结论</p>
<ul>
<li>在主线程顺序执行，不开启新的线程</li>
<li>主队列的特点：只有当主线程空闲时，主队列才会调度任务到主线程执行</li>
<li>主队列就算是异步执行也不会开启新的线程</li>
<li>主队列相当于一个全局的串行队列</li>
<li>主队列和串行队列的区别</li>
<li>串行队列:必须等待一个任务执行完毕，才会调度下一个任务。</li>
<li>主队列:如果主线程上有代码执行，主队列就不调度任务。</li>
</ul>
<h3 id="5-4-主队列-同步执行（死锁）"><a href="#5-4-主队列-同步执行（死锁）" class="headerlink" title="5.4 主队列 同步执行（死锁）"></a>5.4 主队列 同步执行（死锁）</h3><p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@&quot;begin&quot;);</span><br><span class="line">// 1\. 获取主队列</span><br><span class="line">dispatch_queue_t q = dispatch_get_main_queue();</span><br><span class="line">// 2\. 将任务添加到主队列, 并且指定同步执行</span><br><span class="line">// 死锁</span><br><span class="line">for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    dispatch_sync(q, ^&#123;</span><br><span class="line">        NSLog(@&quot;%@ %d&quot;, [NSThread currentThread], i);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">NSLog(@&quot;end&quot;);</span><br></pre></td></tr></table></figure>


<p>打印</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2016-02-25 21:19:25.986 test[791:790967] begin</span><br></pre></td></tr></table></figure>


<p><code>打印结果可以看出，不是想要的结果，这时候发生了死锁，在主线程执行，主队列同步执行任务，会发生死锁，主线程和主队列同步任务相互等待，造成死锁</code></p>
<h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@&quot;begin&quot;);</span><br><span class="line">dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">    NSLog(@&quot;--- %@&quot;, [NSThread currentThread]);</span><br><span class="line">    // 1\. 获取主队列</span><br><span class="line">    dispatch_queue_t q = dispatch_get_main_queue();</span><br><span class="line">    // 2\. 将任务添加到主队列, 并且指定同步执行</span><br><span class="line">    // 死锁</span><br><span class="line">    for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">        dispatch_sync(q, ^&#123;</span><br><span class="line">            NSLog(@&quot;%@ %d&quot;, [NSThread currentThread], i);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">NSLog(@&quot;end&quot;);</span><br></pre></td></tr></table></figure>


<p>打印</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">2016-02-25 21:23:23.205 test[803:794826] begin  </span><br><span class="line">2016-02-25 21:23:23.206 test[803:794826] end  </span><br><span class="line">2016-02-25 21:23:23.206 test[803:794866] --- &lt;NSThread: 0x7f8830514cb0&gt;&#123;number = 2, name = (null)&#125;  </span><br><span class="line">2016-02-25 21:23:23.209 test[803:794826] &lt;NSThread: 0x7f8830507dd0&gt;&#123;number = 1, name = main&#125; 0  </span><br><span class="line">2016-02-25 21:23:23.209 test[803:794826] &lt;NSThread: 0x7f8830507dd0&gt;&#123;number = 1, name = main&#125; 1  </span><br><span class="line">2016-02-25 21:23:23.209 test[803:794826] &lt;NSThread: 0x7f8830507dd0&gt;&#123;number = 1, name = main&#125; 2  </span><br><span class="line">2016-02-25 21:23:23.209 test[803:794826] &lt;NSThread: 0x7f8830507dd0&gt;&#123;number = 1, name = main&#125; 3  </span><br><span class="line">2016-02-25 21:23:23.209 test[803:794826] &lt;NSThread: 0x7f8830507dd0&gt;&#123;number = 1, name = main&#125; 4  </span><br><span class="line">2016-02-25 21:23:23.210 test[803:794826] &lt;NSThread: 0x7f8830507dd0&gt;&#123;number = 1, name = main&#125; 5  </span><br><span class="line">2016-02-25 21:23:23.210 test[803:794826] &lt;NSThread: 0x7f8830507dd0&gt;&#123;number = 1, name = main&#125; 6  </span><br><span class="line">2016-02-25 21:23:23.210 test[803:794826] &lt;NSThread: 0x7f8830507dd0&gt;&#123;number = 1, name = main&#125; 7  </span><br><span class="line">2016-02-25 21:23:23.210 test[803:794826] &lt;NSThread: 0x7f8830507dd0&gt;&#123;number = 1, name = main&#125; 8  </span><br><span class="line">2016-02-25 21:23:23.210 test[803:794826] &lt;NSThread: 0x7f8830507dd0&gt;&#123;number = 1, name = main&#125; 9</span><br></pre></td></tr></table></figure>


<p><code>打印结果可以看出，当我们将主队列同步执行任务放到子线程去执行，就不会出现死锁。由于将主队列同步放到了子线程中执行，主队列同步任务无法阻塞主线程执行代码，因此主线程可以将主线程上的代码执行完毕。当主线程执行完毕之后，就会执行主队列里面的任务。</code></p>
<h2 id="6、全局队列"><a href="#6、全局队列" class="headerlink" title="6、全局队列"></a>6、全局队列</h2><p>全局队列是系统提供的，无需自己创建，可以直接通过<code>dispatch_get_global_queue(long identifier, unsigned long flags);</code>函数来获取。</p>
<h3 id="6-1-全局队列-异步执行"><a href="#6-1-全局队列-异步执行" class="headerlink" title="6.1 全局队列 异步执行"></a>6.1 全局队列 异步执行</h3><p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 1\. 获取全局队列</span><br><span class="line">dispatch_queue_t q = dispatch_get_global_queue(0, 0);</span><br><span class="line">// 2\. 将任务添加到全局队列, 异步执行</span><br><span class="line">for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    dispatch_async(q, ^&#123;</span><br><span class="line">        NSLog(@&quot;%d %@&quot;, i, [NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>打印输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">2016-02-25 21:29:06.978 test[816:799523] 1 &lt;NSThread: 0x7fd428e15760&gt;&#123;number = 3, name = (null)&#125;  </span><br><span class="line">2016-02-25 21:29:06.978 test[816:799530] 4 &lt;NSThread: 0x7fd428d2fbb0&gt;&#123;number = 6, name = (null)&#125;  </span><br><span class="line">2016-02-25 21:29:06.978 test[816:799522] 0 &lt;NSThread: 0x7fd428f094e0&gt;&#123;number = 2, name = (null)&#125;  </span><br><span class="line">2016-02-25 21:29:06.978 test[816:799529] 3 &lt;NSThread: 0x7fd428c0e1b0&gt;&#123;number = 5, name = (null)&#125;  </span><br><span class="line">2016-02-25 21:29:06.978 test[816:799532] 6 &lt;NSThread: 0x7fd428f06740&gt;&#123;number = 7, name = (null)&#125;  </span><br><span class="line">2016-02-25 21:29:06.978 test[816:799533] 7 &lt;NSThread: 0x7fd428d37be0&gt;&#123;number = 8, name = (null)&#125;  </span><br><span class="line">2016-02-25 21:29:06.978 test[816:799531] 5 &lt;NSThread: 0x7fd428e0c490&gt;&#123;number = 9, name = (null)&#125;  </span><br><span class="line">2016-02-25 21:29:06.978 test[816:799526] 2 &lt;NSThread: 0x7fd428d3e4b0&gt;&#123;number = 4, name = (null)&#125;  </span><br><span class="line">2016-02-25 21:29:06.979 test[816:799534] 8 &lt;NSThread: 0x7fd428d36ab0&gt;&#123;number = 10, name = (null)&#125;  </span><br><span class="line">2016-02-25 21:29:06.979 test[816:799523] 9 &lt;NSThread: 0x7fd428e15760&gt;&#123;number = 3, name = (null)&#125;</span><br></pre></td></tr></table></figure>


<h5 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h5><ol>
<li>全局队列的工作特性跟并发队列一致。 实际上，全局队列就是系统为了方便程序员，专门提供的一种特殊的并发队列。</li>
<li>全局队列和并发队列的区别：</li>
</ol>
<ul>
<li>全局队列没有名称，无论ARC还是MRC都不需要考虑内存释放，日常开发，建议使用全局队列</li>
<li>并发队列有名称，如果在MRC开发中，需要使用<code>dispatch_release</code>来释放相应的对象，<code>dispatch_barrier</code> 必须使用自定义的并发队列，开发第三方框架，建议使用并发队列</li>
</ul>
<h3 id="6-2、函数"><a href="#6-2、函数" class="headerlink" title="6.2、函数"></a>6.2、函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_get_global_queue(long identifier, unsigned long flags);</span><br></pre></td></tr></table></figure>
<p>这个函数中有两个参数:<br>第一个参数: <code>identifier </code><br>iOS7.0，表示的是优先级:<br><code>DISPATCH_QUEUE_PRIORITY_HIGH = 2;</code> 高优先级<br><code>DISPATCH_QUEUE_PRIORITY_DEFAULT = 0;</code> 默认优先级<br><code>DISPATCH_QUEUE_PRIORITY_LOW = -2;</code> 低优先级<br><code>DISPATCH_QUEUE_PRIORITY_BACKGROUND = INT16_MIN; </code>后台优先级<br>iOS8.0开始，推荐使用服务质量(QOS):<br><code>QOS_CLASS_USER_INTERACTIVE = 0x21;</code> 用户交互<br><code>QOS_CLASS_USER_INITIATED = 0x19;</code> 用户期望<br><code>QOS_CLASS_DEFAULT = 0x15;</code> 默认<br><code>QOS_CLASS_UTILITY = 0x11;</code> 实用工具<br><code>QOS_CLASS_BACKGROUND = 0x09;</code> 后台<br><code>QOS_CLASS_UNSPECIFIED = 0x00;</code> 未指定<br>通过对比可知: 第一个参数传入0，可以同时适配iOS7及iOS7以后的版本。<br>服务质量和优先级是一一对应的:  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_QUEUE_PRIORITY_HIGH: QOS_CLASS_USER_INITIATED  </span><br><span class="line">DISPATCH_QUEUE_PRIORITY_DEFAULT: QOS_CLASS_DEFAULT  </span><br><span class="line">DISPATCH_QUEUE_PRIORITY_LOW: QOS_CLASS_UTILITY  </span><br><span class="line">DISPATCH_QUEUE_PRIORITY_BACKGROUND: QOS_CLASS_BACKGROUND</span><br></pre></td></tr></table></figure>

<p>第二个参数: <code>flags  </code><br>为未来保留使用的，始终传入0。<br><code>Reserved for future use.</code></p>
<h2 id="7、GCD总结"><a href="#7、GCD总结" class="headerlink" title="7、GCD总结"></a>7、GCD总结</h2><h3 id="1、开不开线程，由执行任务的函数决定"><a href="#1、开不开线程，由执行任务的函数决定" class="headerlink" title="1、开不开线程，由执行任务的函数决定"></a>1、开不开线程，由执行任务的函数决定</h3><ul>
<li>同步执行不开线程</li>
<li>异步执行开线程</li>
</ul>
<h3 id="2、异步执行任务，开几条线程由队列决定"><a href="#2、异步执行任务，开几条线程由队列决定" class="headerlink" title="2、异步执行任务，开几条线程由队列决定"></a>2、异步执行任务，开几条线程由队列决定</h3><ul>
<li>串行队列，只会开一条线程，因为一条就足够了</li>
<li>并发队列，可以开多条线程，具体开几条由线程池决定</li>
</ul>
<p><code>对主队列而言，不管是同步执行还是异步执行，都不会开线程。</code></p>
<h3 id="最后盗图总结一张"><a href="#最后盗图总结一张" class="headerlink" title="最后盗图总结一张"></a>最后盗图总结一张</h3><p><img src="https://upload-images.jianshu.io/upload_images/1442184-2b22e764ef8e39b8.jpg" alt="image"></p>
<hr>
<h1 id="六、NSOperation"><a href="#六、NSOperation" class="headerlink" title="六、NSOperation"></a>六、NSOperation</h1><h2 id="1、NSOperation简介"><a href="#1、NSOperation简介" class="headerlink" title="1、NSOperation简介"></a>1、NSOperation简介</h2><h3 id="1-1-NSOperation与GCD的区别："><a href="#1-1-NSOperation与GCD的区别：" class="headerlink" title="1.1 NSOperation与GCD的区别："></a>1.1 NSOperation与GCD的区别：</h3><ul>
<li>OC语言中基于 GCD 的面向对象的封装;</li>
<li>使用起来比 GCD 更加简单;</li>
<li>提供了一些用 GCD 不好实现的功能;</li>
<li>苹果推荐使用，使用 NSOperation 程序员不用关心线程的生命周期</li>
</ul>
<h3 id="1-2NSOperation的特点"><a href="#1-2NSOperation的特点" class="headerlink" title="1.2NSOperation的特点"></a>1.2NSOperation的特点</h3><ul>
<li>NSOperation 是一个抽象类，抽象类不能直接使用,必须使用它的子类</li>
<li>抽象类的用处是定义子类共有的属性和方法</li>
</ul>
<h2 id="2、核心概念"><a href="#2、核心概念" class="headerlink" title="2、核心概念"></a>2、核心概念</h2><ul>
<li><p>将操作添加到队列，异步执行。相对于GCD创建任务，将任务添加到队列。</p>
</li>
<li><p>将NSOperation添加到NSOperationQueue就可以实现多线程编程</p>
</li>
</ul>
<h2 id="3、操作步骤"><a href="#3、操作步骤" class="headerlink" title="3、操作步骤"></a>3、操作步骤</h2><ul>
<li>先将需要执行的操作封装到一个NSOperation对象中</li>
<li>然后将NSOperation对象添加到NSOperationQueue中</li>
<li>系统会自动将NSOperationQueue中的NSOperation取出来</li>
<li>将取出的NSOperation封装的操作放到一条新线程中执行</li>
</ul>
<h2 id="4、NSInvocationOperation"><a href="#4、NSInvocationOperation" class="headerlink" title="4、NSInvocationOperation"></a>4、<code>NSInvocationOperation</code></h2><h3 id="方式一-1"><a href="#方式一-1" class="headerlink" title="方式一"></a>方式一</h3><p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;  </span><br><span class="line">    [super viewDidLoad];  </span><br><span class="line">    //创建操作，然后调用操作的start方法  </span><br><span class="line">    NSInvocationOperation *op = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(demo) object:nil];  </span><br><span class="line">    NSLog(@&quot;%d&quot;,op.isFinished);  </span><br><span class="line">    [op start];  </span><br><span class="line">    NSLog(@&quot;%d&quot;,op.isFinished);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)demo &#123;  </span><br><span class="line">    NSLog(@&quot;hello %@&quot;,[NSThread currentThread]);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>打印输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2016-02-25 22:12:30.054 test[892:834660] 0  </span><br><span class="line">2016-02-25 22:12:30.054 test[892:834660] hello &lt;NSThread: 0x7fad12704f80&gt;&#123;number = 1, name = main&#125;  </span><br><span class="line">2016-02-25 22:12:30.054 test[892:834660] 1</span><br></pre></td></tr></table></figure>


<p>结论：<code>[op start]在主线程中调用的，所以执行的线程也会是在主线程执行！ 重复调用start也只会执行一次，因为NSOperation会有一个属性去记住，是否已经完成了该操作！</code></p>
<h3 id="方式二-1"><a href="#方式二-1" class="headerlink" title="方式二"></a>方式二</h3><p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;  </span><br><span class="line">    [super viewDidLoad];  </span><br><span class="line">    // 创建操作，将操作添加到NSOperationQueue中，然后就会异步的自动执行  </span><br><span class="line">    NSInvocationOperation *op = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(demo) object:nil];  </span><br><span class="line">    //队列  </span><br><span class="line">    NSOperationQueue *queue = [[NSOperationQueue alloc] init];  </span><br><span class="line">    //把操作添加到队列  </span><br><span class="line">    [queue addOperation:op];  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)demo &#123;  </span><br><span class="line">    NSLog(@&quot;hello %@&quot;,[NSThread currentThread]);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>打印</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2016-02-25 22:21:44.999 test[912:842412] hello &lt;NSThread: 0x7fab92610080&gt;&#123;number = 2, name = (null)&#125;</span><br></pre></td></tr></table></figure>

<p><code>将操作添加到NSOperationQueue中，然后就会异步的自动执行</code></p>
<h2 id="5、NSBlockOperation"><a href="#5、NSBlockOperation" class="headerlink" title="5、NSBlockOperation"></a>5、NSBlockOperation</h2><ul>
<li>NSBlockOperation 中使用block的方式让所有代码逻辑在一起，使用起来更加简便。**</li>
</ul>
<h3 id="方式一-2"><a href="#方式一-2" class="headerlink" title="方式一"></a>方式一</h3><p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//创建操作  </span><br><span class="line">NSBlockOperation *op = [NSBlockOperation blockOperationWithBlock:^&#123;  </span><br><span class="line">NSLog(@&quot;hello %@&quot;,[NSThread currentThread]);  </span><br><span class="line">&#125;];  </span><br><span class="line">//更新op的状态，执行main方法，不会开新线程  </span><br><span class="line">[op start];</span><br></pre></td></tr></table></figure>


<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2016-02-25 22:25:30.442 test[923:846208] hello &lt;NSThread: 0x7fd410d055a0&gt;&#123;number = 1, name = main&#125;</span><br></pre></td></tr></table></figure>


<h3 id="方式二-2"><a href="#方式二-2" class="headerlink" title="方式二"></a>方式二</h3><p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 创建队列，创建操作，将操作添加到队列中执行  </span><br><span class="line">NSOperationQueue *queue = [[NSOperationQueue alloc] init];  </span><br><span class="line">NSBlockOperation *op = [NSBlockOperation blockOperationWithBlock:^&#123;  </span><br><span class="line">NSLog(@&quot;hello %@&quot;,[NSThread currentThread]);  </span><br><span class="line">&#125;];  </span><br><span class="line">[queue addOperation:op];</span><br></pre></td></tr></table></figure>


<p>输出  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2016-02-25 22:26:48.064 test[934:848038] hello &lt;NSThread: 0x7fc6bbb24c80&gt;&#123;number = 2, name = (null)&#125;</span><br></pre></td></tr></table></figure>


<h3 id="方式三-1"><a href="#方式三-1" class="headerlink" title="方式三"></a>方式三</h3><p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NSOperationQueue *queue = [[NSOperationQueue alloc] init];</span><br><span class="line"></span><br><span class="line">[queue addOperationWithBlock:^&#123;</span><br><span class="line">    NSLog(@&quot;hello %@&quot;,[NSThread currentThread]);</span><br><span class="line"></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>


<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2016-02-25 22:27:56.445 test[945:850128] hello &lt;NSThread: 0x7f98dbc2cae0&gt;&#123;number = 2, name = (null)&#125;</span><br></pre></td></tr></table></figure>

<p><code>创建队列，添加block形式的操作</code></p>
<hr>
<h1 id="七、案例"><a href="#七、案例" class="headerlink" title="七、案例"></a>七、案例</h1><h2 id="线程之间的通信问题"><a href="#线程之间的通信问题" class="headerlink" title="线程之间的通信问题"></a>线程之间的通信问题</h2><h3 id="技术方案：NSOperation"><a href="#技术方案：NSOperation" class="headerlink" title="技术方案：NSOperation"></a>技术方案：NSOperation</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[self.queue addOperationWithBlock:^&#123;  </span><br><span class="line">    NSLog(@&quot;异步下载图片&quot;);  </span><br><span class="line">    [[NSOperationQueue mainQueue] addOperationWithBlock:^&#123;  </span><br><span class="line">        NSLog(@&quot;回到主线程，更新UI&quot;);  </span><br><span class="line">    &#125;];  </span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>


<h3 id="技术方案：GCD"><a href="#技术方案：GCD" class="headerlink" title="技术方案：GCD"></a>技术方案：GCD</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">    NSLog(@&quot;下载图片---%@&quot;,[NSThread currentThread]);</span><br><span class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        NSLog(@&quot;回到主线程刷新图片的显示 -%@&quot;,[NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>

  









    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2023 John Doe
    
  </p>
</footer>
    
    
  </div>
</div>
</body>
</html>