<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo</title>

  
  <meta name="author" content="John Doe">
  

  

  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  

  <meta property="og:site_name" content="Hexo"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">Hexo</a>
    </h1>
    <p class="site-description"></p>
  </div>
  <nav class="site-navigation">
    <ul>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    
  <article>

  
    
    <h3 class="article-title"><a href="/2023/03/24/KVC KVO/"><span></span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2023/03/24/KVC KVO/" rel="bookmark">
        <time class="entry-date published" datetime="2023-03-24T03:56:52.084Z">
          2023-03-24
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="说一下KVC和KVO"><a href="#说一下KVC和KVO" class="headerlink" title="说一下KVC和KVO"></a>说一下KVC和KVO</h1><p>
        <span class="lazyload-img-span">
        <img   
           data-src="https://lymanli-1258009115.cos.ap-guangzhou.myqcloud.com/image/blog/kvc-kvo.jpg" >
        </sapn>
      <br>本篇采用简单的例子，来介绍 iOS 中的 KVC 和 KVO 的用法和实现原理。  </p>
<h1 id="一、KVC"><a href="#一、KVC" class="headerlink" title="一、KVC"></a>一、KVC</h1><h2 id="1-KVC是什么"><a href="#1-KVC是什么" class="headerlink" title="1. KVC是什么"></a>1. KVC是什么</h2><p>KVC 即 Key-Value Coding，翻译成键值编码。它是一种不通过存取方法，而通过属性名称字符串间接访问属性的机制。</p>
<h2 id="2-KVC的用法"><a href="#2-KVC的用法" class="headerlink" title="2. KVC的用法"></a>2. KVC的用法</h2><p>KVC 常用到的方法有下面几个：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (id)valueForKey:(NSString *)key;  </span><br><span class="line">- (void)setValue:(nullable id)value forKey:(NSString *)key;  </span><br><span class="line">  </span><br><span class="line">- (nullable id)valueForKeyPath:(NSString *)keyPath;  </span><br><span class="line">- (void)setValue:(nullable id)value forKeyPath:(NSString *)keyPath;</span><br></pre></td></tr></table></figure>
<p>前面的两个方法，以字符串的形式传入对象属性即可调用。<strong>私有属性也可以调用</strong>。如下代码所示：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 先声明一个对象ObjectA，同时具备私有属性和公有属性  </span><br><span class="line">// ObjectA.h  </span><br><span class="line">@interface ObjectA : NSObject  </span><br><span class="line">  </span><br><span class="line">@property (nonatomic, strong) NSString *publicPropertyString;  </span><br><span class="line">  </span><br><span class="line">@end  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">// ObjectA.m  </span><br><span class="line">@interface ObjectA ()  </span><br><span class="line">  </span><br><span class="line">@property (nonatomic, assign) NSInteger privatePropertyInteger;  </span><br><span class="line">  </span><br><span class="line">@end  </span><br><span class="line">  </span><br><span class="line">@implementation ObjectA  </span><br><span class="line">  </span><br><span class="line">- (instancetype)init &#123;  </span><br><span class="line">    </span><br><span class="line">    self = [super init];  </span><br><span class="line">    if (self) &#123;  </span><br><span class="line">        self.publicPropertyString = @&quot;publicPropertyString&quot;;  </span><br><span class="line">        self.privatePropertyInteger = 2000; </span><br><span class="line">    &#125;  </span><br><span class="line">    return self;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">@end</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 尝试调用  </span><br><span class="line">ObjectA *objectA = [[ObjectA alloc] init];  </span><br><span class="line">  </span><br><span class="line">// 以下输出：publicPropertyString   </span><br><span class="line">NSLog(@&quot;%@&quot;, [objectA valueForKey:@&quot;publicPropertyString&quot;]);   </span><br><span class="line">  </span><br><span class="line">// 以下输出：2000   </span><br><span class="line">NSLog(@&quot;%@&quot;, [objectA valueForKey:@&quot;privatePropertyInteger&quot;]);   </span><br><span class="line">    </span><br><span class="line">// 将999赋值给privatePropertyInteger  </span><br><span class="line">[objectA setValue:@(999) forKey:@&quot;privatePropertyInteger&quot;];  </span><br><span class="line">  </span><br><span class="line">// 以下输出：999  </span><br><span class="line">NSLog(@&quot;%@&quot;, [objectA valueForKey:@&quot;privatePropertyInteger&quot;]);</span><br></pre></td></tr></table></figure>
<p>后面两个方法支持传入用 <code>.</code> 连接的多层级属性，比如 <code>school.schoolmaster.name</code> 。<strong>同样支持私有属性</strong>。如下代码所示：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 再声明一个对象ObjectB，具备私有属性ObjectA</span><br><span class="line">// ObjectB.m</span><br><span class="line">@interface ObjectB ()</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong) ObjectA *objectA;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ObjectB</span><br><span class="line"></span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">    </span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        self.objectA = [[ObjectA alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>





<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 尝试调用  </span><br><span class="line">ObjectB *objectB = [[ObjectB alloc] init];  </span><br><span class="line">  </span><br><span class="line">// 将999赋值给objectA的属性privatePropertyInteger  </span><br><span class="line">[objectB setValue:@(999) forKeyPath:@&quot;objectA.privatePropertyInteger&quot;];  </span><br><span class="line">  </span><br><span class="line">// 以下输出：999  </span><br><span class="line">NSLog(@&quot;%@&quot;, [objectB valueForKeyPath:@&quot;objectA.privatePropertyInteger&quot;]);</span><br></pre></td></tr></table></figure>
<p><strong>需要注意</strong>：</p>
<ul>
<li>当 <code>value</code> 的值为基本类型时，应该封装为 <code>NSNumber</code> 或 <code>NSValue</code> 。</li>
<li><strong>KVC不会自动调用键值验证方法</strong>。当字符串中的属性值不存在时，会直接抛出异常。</li>
<li>可以先在类中重写 <code>-validateValue: forKey: error:</code> ，制定检查规则，然后手动调用该方法来验证。</li>
<li><strong>KVC的一个重要应用是字典转模型</strong>。</li>
</ul>
<h2 id="3-KVC的原理"><a href="#3-KVC的原理" class="headerlink" title="3. KVC的原理"></a>3. KVC的原理</h2><p>为了设置或者获取对象属性，KVC按顺序使用如下技术：</p>
<ol>
<li>获取对象属性时，检查是否存在 <code>-&lt;key&gt;</code> 、 <code>-is&lt;key&gt;</code>（只针对布尔值有效）或者 <code>-get&lt;key&gt;</code> 的访问器方法，如果找到，就用这些方法来返回属性值；设置对象属性时，检查是否存在名为 <code>-set&lt;key&gt;:</code> 的方法，并使用它来设置属性值。对于 <code>-get&lt;key&gt;</code> 和 <code>-set&lt;key&gt;:</code> 方法，将大写Key字符串的第一个字母，并与Cocoa的方法命名保持一致。</li>
<li>如果上述方法找不到，则检查名为 <code>-_&lt;key&gt;</code> 、 <code>-_is&lt;key&gt;</code>（只针对布尔值有效）、 <code>-_get&lt;key&gt;</code> 和 <code>-_set&lt;key&gt;:</code> 方法。</li>
<li>如果没有找到访问器方法，则尝试直接访问实例变量。实例变量可以是名为： <code>&lt;key&gt;</code> 或 <code>_&lt;key&gt;</code> 。</li>
<li>如果仍未找到，则调用 <code>valueForUndefinedKey:</code> 和 <code>setValue:forUndefinedKey:</code> 方法。这些方法的默认实现都是抛出异常，可以根据需要重写它们。</li>
</ol>
<p>可以看到，<strong>KVC会优先使用访问器方法来访问对象属性</strong>。</p>
<h1 id="二、KVO"><a href="#二、KVO" class="headerlink" title="二、KVO"></a>二、KVO</h1><h2 id="1-KVO是什么"><a href="#1-KVO是什么" class="headerlink" title="1. KVO是什么"></a>1. KVO是什么</h2><p>KVO 即 <code>Key-Value Observing</code>，翻译成键值观察。它是一种观察者模式的衍生。其基本思想是，对目标对象的某属性添加观察，当该属性发生变化时，通过触发观察者对象实现的KVO接口方法，来自动的通知观察者。</p>
<h2 id="2-KVO的用法"><a href="#2-KVO的用法" class="headerlink" title="2. KVO的用法"></a>2. KVO的用法</h2><p>KVO的使用主要分为三步：</p>
<p><strong>第一步，将目标对象添加为观察者。</strong>（注意这里用到了KVC，即通过字符串的方式去访问属性值。）  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)addObserver:(NSObject *)observer  </span><br><span class="line"> forKeyPath:(NSString *)keyPath  </span><br><span class="line"> options:(NSKeyValueObservingOptions)options  </span><br><span class="line"> context:(nullable void *)context;</span><br></pre></td></tr></table></figure>
<p><strong>第二步，实现接收通知的接口方法。</strong>  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)observeValueForKeyPath:(nullable NSString *)keyPath  </span><br><span class="line"> ofObject:(nullable id)object  </span><br><span class="line"> change:(nullable NSDictionary&lt;NSKeyValueChangeKey, id&gt; *)change  </span><br><span class="line"> context:(nullable void *)context;</span><br></pre></td></tr></table></figure>

<p><strong>第三步，移除观察者。</strong>  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void)removeObserver:(NSObject *)observer</span><br><span class="line"> forKeyPath:(NSString *)keyPath;</span><br></pre></td></tr></table></figure>
<p>在第一步中，NSKeyValueObservingOptions类型有四个取值，可以通过 <code>|</code> 来连接多个取值。分别为：</p>
<ul>
<li><strong>NSKeyValueObservingOptionNew</strong>，在属性值变化的时候回调，可以在change中取到<strong>变化后</strong>的值。</li>
<li><strong>NSKeyValueObservingOptionOld</strong>，在属性值变化的时候回调，可以在change中取到<strong>变化前</strong>的值。</li>
<li><strong>NSKeyValueObservingOptionInitial</strong>，在属性值初始化或者变化的时候回调，拿不到变化前后的值。</li>
<li><strong>NSKeyValueObservingOptionPrior</strong>，在属性值变化前和变化后各回调一次，拿不到变化前后的值。</li>
</ul>
<p>举一个例子：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">@interface ObjectB ()  </span><br><span class="line">  </span><br><span class="line">@property (nonatomic, strong) ObjectA *objectA;  </span><br><span class="line">  </span><br><span class="line">@end  </span><br><span class="line">  </span><br><span class="line">@implementation ObjectB  </span><br><span class="line">  </span><br><span class="line">- (instancetype)init &#123;  </span><br><span class="line">    self = [super init];  </span><br><span class="line">    if (self) &#123;  </span><br><span class="line">        self.objectA = [[ObjectA alloc] init];  </span><br><span class="line">        // 第一步，将目标对象添加为观察者  </span><br><span class="line">        [_objectA addObserver:self  </span><br><span class="line">        forKeyPath:@&quot;privatePropertyInteger&quot; options:NSKeyValueObservingOptionNew context:nil];  </span><br><span class="line">        [_objectA setValue:@(999) forKey:@&quot;privatePropertyInteger&quot;;</span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    return self;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">// 第二步，实现接收通知的接口方法  </span><br><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath  </span><br><span class="line"> ofObject:(id)object  </span><br><span class="line"> change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change  </span><br><span class="line"> context:(void *)context &#123;  </span><br><span class="line">    </span><br><span class="line">    // 这里最好判断一下object的类型和keyPath的值，不符合则交给父类处理  </span><br><span class="line">    if ([object isKindOfClass:[ObjectA class]] &amp;&amp;  [keyPath isEqualToString:@&quot;privatePropertyInteger&quot;]) &#123;  </span><br><span class="line">        NSLog(@&quot;%@&quot;, change);  // 这里可以读取到 new = 999  </span><br><span class="line">    &#125; else &#123;  </span><br><span class="line">        [super observeValueForKeyPath:keyPath ofObject:object change:change  context:context\];  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">// 第三步，移除观察者。  </span><br><span class="line">- (void) dealloc &#123;  </span><br><span class="line">    </span><br><span class="line">    [_objectA removeObserver:self  forKeyPath:@&quot;privatePropertyInteger&quot;\];  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">@end</span><br></pre></td></tr></table></figure>


<p>KVO可以在MVC模式中得到很好的应用。因为当Model发生变化时，通过KVO可以很方便地通知到Controller，从而通过Controller来改变View的展示。所以说<strong>KVO是解决Model和View同步的好办法。</strong></p>
<h2 id="3-KVO的原理"><a href="#3-KVO的原理" class="headerlink" title="3. KVO的原理"></a>3. KVO的原理</h2><p>KVO的实现依赖于Runtime的强大动态能力。</p>
<p><strong>当某个类的对象第一次被观察时，系统就会在运行期动态地创建该类的一个派生类，在这个派生类中重写这个类中任何被观察属性的 setter 方法。</strong></p>
<p>即当一个类型为 ObjectA 的对象，被添加了观察后，系统会生成一个 NSKVONotifying_ObjectA 类，并将对象的isa指针指向新的类，也就是说这个对象的类型发生了变化。这个类相比较于ObjectA，会重写以下几个方法。</p>
<h3 id="1-重写setter"><a href="#1-重写setter" class="headerlink" title="1. 重写setter"></a>1. 重写setter</h3><p>在 setter 中，会添加以下两个方法的调用。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void)willChangeValueForKey:(NSString *)key;  </span><br><span class="line">- (void)didChangeValueForKey:(NSString *)key;</span><br></pre></td></tr></table></figure>
<p>然后在 <code>didChangeValueForKey:</code> 中，去调用：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)observeValueForKeyPath:(nullable NSString *)keyPath  </span><br><span class="line"> ofObject:(nullable id)object  </span><br><span class="line"> change:(nullable NSDictionary&lt;NSKeyValueChangeKey, id&gt; *)change  </span><br><span class="line"> context:(nullable void *)context;</span><br></pre></td></tr></table></figure>


<p>于是实现了属性值修改的通知。因为 KVO 的原理是修改 setter 方法，因此使用 KVO 必须调用 setter 。若直接访问属性对象则没有效果。</p>
<h3 id="2-重写class"><a href="#2-重写class" class="headerlink" title="2. 重写class"></a>2. 重写class</h3><p>当修改了isa指向后，class的返回值不会变，但isa的值则发生改变。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 添加Observer之后  </span><br><span class="line">  </span><br><span class="line">// 输出ObjectA  </span><br><span class="line">NSLog(@&quot;%@&quot;, [_objectA class]);   </span><br><span class="line">  </span><br><span class="line">// 输出NSKVONotifying_ObjectA（object_getClass方法返回isa指向）  </span><br><span class="line">NSLog(@&quot;%@&quot;, object_getClass(_objectA));</span><br></pre></td></tr></table></figure>
<h3 id="3-重写dealloc"><a href="#3-重写dealloc" class="headerlink" title="3. 重写dealloc"></a>3. 重写dealloc</h3><p>系统重写 dealloc 方法来释放资源。</p>
<h3 id="4-重写-isKVOA"><a href="#4-重写-isKVOA" class="headerlink" title="4. 重写_isKVOA"></a>4. 重写_isKVOA</h3><p>这个私有方法估计是用来标示该类是一个 KVO 机制声称的类。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="#参考 "></a>#参考 </h1><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/66bda10168f1">KVC和KVO的使用及原理</a><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/wzzvictory/article/details/9674431">KVC&#x2F;KVO原理详解及编程指南</a><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/dizzthxl/article/details/9034659">iOS里的KVO模式</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2023/03/24/iOS多线程/"><span></span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2023/03/24/iOS多线程/" rel="bookmark">
        <time class="entry-date published" datetime="2023-03-24T03:55:38.078Z">
          2023-03-24
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="一、多线程简介"><a href="#一、多线程简介" class="headerlink" title="一、多线程简介"></a>一、多线程简介</h1><h2 id="1、多线程的由来"><a href="#1、多线程的由来" class="headerlink" title="1、多线程的由来"></a>1、多线程的由来</h2><p><strong>一个进程（进程）在执行一个线程（线程中有很多函数或方法（后面简称Function））的时候，其中有一个Function执行的时候需要消耗一些时间，但是这个线程又必须同时执行这个Function之后的Function，问题来了，一个线程中的任何一个Function都必须等待其执行完成后才能执行后面的Function，如果要同时执行两个或者多个Function，那么，就必须多开一个或者多个线程，这就是多线程的产生。我想多线程最开始的诞生就是由这而来吧！</strong></p>
<h2 id="2、耗时操作的模拟试验"><a href="#2、耗时操作的模拟试验" class="headerlink" title="2、耗时操作的模拟试验"></a>2、耗时操作的模拟试验</h2><h3 id="2-1-循环测试"><a href="#2-1-循环测试" class="headerlink" title="2.1 循环测试"></a>2.1 循环测试</h3><p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">        @autoreleasepool &#123;</span><br><span class="line">            NSLog(@&quot;bengin&quot;);</span><br><span class="line">            for (int i = 0; i &lt; 10000000; i++) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            NSLog(@&quot;end&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>控制台</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2016-02-16 13:51:54.140 Test[1670:603696] bengin  </span><br><span class="line">2016-02-16 13:51:54.160 Test[1670:603696] end  </span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>

<p><code>结论一：循环一亿次耗时0.02秒，计算机的运行速度是非常快的</code></p>
<h3 id="2-2-操作栈区"><a href="#2-2-操作栈区" class="headerlink" title="2.2 操作栈区"></a>2.2 操作栈区</h3><p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">        @autoreleasepool &#123;</span><br><span class="line">            NSLog(@&quot;bengin&quot;);</span><br><span class="line">            for (int i = 0; i &lt; 10000000; i++) &#123;</span><br><span class="line">                int n = 1;</span><br><span class="line">            &#125;</span><br><span class="line">            NSLog(@&quot;end&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p>控制台</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2016-02-16 13:57:37.589 Test[1734:631377] bengin  </span><br><span class="line">2016-02-16 13:57:37.612 Test[1734:631377] end  </span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>


<p><code>结论二：对栈区操作一亿次，耗时0.023秒</code></p>
<h3 id="2-3-操作常量区"><a href="#2-3-操作常量区" class="headerlink" title="2.3 操作常量区"></a>2.3 操作常量区</h3><p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        NSLog(@&quot;bengin&quot;);</span><br><span class="line">        for (int i = 0; i &lt; 10000000; i++) &#123;</span><br><span class="line">            NSString *str = @&quot;hellow&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        NSLog(@&quot;end&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>控制台</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2016-02-16 14:03:59.003 Test[1763:659287] bengin  </span><br><span class="line">2016-02-16 14:03:59.113 Test[1763:659287] end  </span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>

<p><code>结论三：对常量区操作一亿次，耗时0.11秒</code></p>
<h3 id="2-4-操作堆区"><a href="#2-4-操作堆区" class="headerlink" title="2.4 操作堆区"></a>2.4 操作堆区</h3><p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        NSLog(@&quot;bengin&quot;);</span><br><span class="line">        for (int i = 0; i &lt; 10000000; i++) &#123;</span><br><span class="line">            NSString *str = [NSString stringWithFormat:@&quot;%d&quot;,i];</span><br><span class="line">        &#125;</span><br><span class="line">        NSLog(@&quot;end&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>控制台</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2016-02-16 14:09:03.673 Test[1786:673719] bengin  </span><br><span class="line">2016-02-16 14:09:10.705 Test[1786:673719] end  </span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<p><code>结论四：对堆区操作一亿次耗时7秒多一些，较慢！</code></p>
<h3 id="2-5-I-x2F-O操作"><a href="#2-5-I-x2F-O操作" class="headerlink" title="2.5 I&#x2F;O操作"></a>2.5 I&#x2F;O操作</h3><p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        NSLog(@&quot;bengin&quot;);</span><br><span class="line">        for (int i = 0; i &lt; 10000000; i++) &#123;</span><br><span class="line">            NSLog(@&quot;%d&quot;,i);</span><br><span class="line">        &#125;</span><br><span class="line">        NSLog(@&quot;end&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>控制台输出！正在跑中，一亿次！！！先看截图<br>CPU  </p>
<p>
        <span class="lazyload-img-span">
        <img   
           data-src="https://upload-images.jianshu.io/upload_images/1442184-06d31ec3a9fa3940.jpg" >
        </sapn>
      </p>
<p>再看内存</p>
<p>
        <span class="lazyload-img-span">
        <img   
           data-src="https://upload-images.jianshu.io/upload_images/1442184-4618f1e39342f9ec.jpg" >
        </sapn>
      </p>
<p>好吧，还在跑，现在已经达到10分钟了，怕心疼本本炸掉！stop。。。<br><code>结论五：I/O操作非常慢，一亿次10分钟也没能跑完！</code></p>
<blockquote>
<p> <strong><code>最终结论：通过以上结论一、二、三、四、五得出一个结论，各个区的执行效率：栈区&gt;常量区&gt;堆区&gt;I/O操作。同时也说明了一个问题，执行不同的方法会产什么耗时操作。这是，为了解决耗时操作问题，多线程闪亮诞生！</code></strong></p>
</blockquote>
<h2 id="3、进程和线程"><a href="#3、进程和线程" class="headerlink" title="3、进程和线程"></a>3、进程和线程</h2><p>先说说进程和线程吧！</p>
<h3 id="3-1-进程"><a href="#3-1-进程" class="headerlink" title="3.1 进程"></a>3.1 进程</h3><h4 id="3-1-1-进程的概念："><a href="#3-1-1-进程的概念：" class="headerlink" title="3.1.1 进程的概念："></a>3.1.1 进程的概念：</h4><p><code>系统中正在运行的应用程序。</code></p>
<h4 id="3-1-2-进程的特点："><a href="#3-1-2-进程的特点：" class="headerlink" title="3.1.2 进程的特点："></a>3.1.2 进程的特点：</h4><p><code>每个进程都运行在其专用且受保护的内存空间，不同的进程之间相互独立，互不干扰。</code></p>
<h3 id="3-2-线程"><a href="#3-2-线程" class="headerlink" title="3.2 线程"></a>3.2 线程</h3><h4 id="3-2-1-线程的概念："><a href="#3-2-1-线程的概念：" class="headerlink" title="3.2.1 线程的概念："></a>3.2.1 线程的概念：</h4><p><code>线程是进程的执行任务的基本单元，一个进程的所有任务都是在线程中执行的。（每一个进程至少要有一条线程）。</code></p>
<h4 id="3-2-2-线程的特点："><a href="#3-2-2-线程的特点：" class="headerlink" title="3.2.2 线程的特点："></a>3.2.2 线程的特点：</h4><p><code>线程在执行任务的时候是按顺序执行的。如果要让一条线程执行多个任务，那么只能一个一个地并且按顺序执行这些任务。也就是说，在同一时间，一条线程只能执行一个任务。</code></p>
<p>我们可以通过Mac中的活动监视器查看进程和线程，下图！</p>
<p>
        <span class="lazyload-img-span">
        <img   
           data-src="https://upload-images.jianshu.io/upload_images/1442184-c62105f160632064.jpg" >
        </sapn>
      </p>
<h2 id="4、多线程的概念及原理"><a href="#4、多线程的概念及原理" class="headerlink" title="4、多线程的概念及原理"></a>4、多线程的概念及原理</h2><h3 id="4-1-多线程概念："><a href="#4-1-多线程概念：" class="headerlink" title="4.1 多线程概念："></a>4.1 多线程概念：</h3><p><code>1个进程可以开启多条线程，多条线程可以同时执行不同的任务。</code></p>
<h3 id="4-2-多线程原理："><a href="#4-2-多线程原理：" class="headerlink" title="4.2 多线程原理："></a>4.2 多线程原理：</h3><p>
        <span class="lazyload-img-span">
        <img   
           data-src="https://upload-images.jianshu.io/upload_images/1442184-12f342316d03e925.jpg" >
        </sapn>
      </p>
<blockquote>
<p> <code>前提是在单核CPU的情况下，同一时间，CPU只能处理一条线程，也就是说只有一条线程在执行任务。多线程同时执行，那是不可能的！但是是CPU快速地在多条线程之间进行调度和切换执行任务。如果CPU调度线程的速度足够快，就会造成多条线程同时执行任务的”假象”，这种假象，就被美誉为：多线程!</code></p>
</blockquote>
<h2 id="5、多线程的优缺点和一个Tip"><a href="#5、多线程的优缺点和一个Tip" class="headerlink" title="5、多线程的优缺点和一个Tip"></a>5、多线程的优缺点和一个Tip</h2><h3 id="5-1-多线程的优点"><a href="#5-1-多线程的优点" class="headerlink" title="5.1 多线程的优点"></a>5.1 多线程的优点</h3><ul>
<li><code>可以适当提高程序的执行效率</code></li>
<li><code>也可以适当提高资源的利用率(CPU、内存利用率)</code></li>
</ul>
<h3 id="5-2-多线程的缺点"><a href="#5-2-多线程的缺点" class="headerlink" title="5.2 多线程的缺点"></a>5.2 多线程的缺点</h3><ul>
<li><code>开启一条线程需要占用一定的内存空间（默认情况下，每一条线程都占用512KB），如果开启大量的线程，会占用大量的内存空间，从而降低程序的性能。</code></li>
<li><code>线程越多，CPU在调度和切换线程上的开销就会越大。</code></li>
<li><code>线程数越多，程序的设计会越复杂。</code></li>
</ul>
<h3 id="5-3-Tip"><a href="#5-3-Tip" class="headerlink" title="5.3 Tip"></a>5.3 Tip</h3><ul>
<li><code>开启新的线程就会消耗资源，但是却可以提高用户体验。在保证良好的用户体验的前提下，可以适当地开线程，一般开3-6条。</code></li>
</ul>
<p>
        <span class="lazyload-img-span">
        <img   
           data-src="https://upload-images.jianshu.io/upload_images/1442184-e7872d1d03c64413.jpg" >
        </sapn>
      </p>
<ul>
<li><code>开启一条新的线程，默认情况下，一条线程都是占用512KB，但是官方的文档里面给出的说明却不是，为了得出真相，下面做个小小的测试！</code></li>
</ul>
<p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        /** 操作主线程 */</span><br><span class="line">        NSLog(@&quot;主线程默认 %tu&quot;, [NSThread currentThread].stackSize / 1024);</span><br><span class="line">        // 设置主线程的stackSize</span><br><span class="line">        [NSThread currentThread].stackSize = 1024 * 1024;</span><br><span class="line">        NSLog(@&quot;主线程修改 %tu&quot;, [NSThread currentThread].stackSize / 1024);</span><br><span class="line">        </span><br><span class="line">        /** 操作子线程 */</span><br><span class="line">        NSThread *thread = [[NSThread alloc] init];</span><br><span class="line">        NSLog(@&quot;thread默认 %tu&quot;, thread.stackSize / 1024);</span><br><span class="line">        // 设置子线程的stackSize</span><br><span class="line">        thread.stackSize = 8 * 1024;</span><br><span class="line">        NSLog(@&quot;thread修改 %tu&quot;, thread.stackSize / 1024);</span><br><span class="line">        [thread start];</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>控制台</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2016-02-17 08:36:02.652 Test[609:110129] 主线程默认 512  </span><br><span class="line">2016-02-17 08:36:02.654 Test[609:110129] 主线程修改 1024  </span><br><span class="line">2016-02-17 08:36:02.654 Test[609:110129] thread默认 512  </span><br><span class="line">2016-02-17 08:36:02.654 Test[609:110129] thread修改 8</span><br></pre></td></tr></table></figure>


<blockquote>
<p><code>证明了，不管什么线程，默认都是512，最小为8.可能是官方文档没有及时更新吧！</code></p>
</blockquote>
<h2 id="6、主线程"><a href="#6、主线程" class="headerlink" title="6、主线程"></a>6、主线程</h2><h3 id="6-1-主线程的概念："><a href="#6-1-主线程的概念：" class="headerlink" title="6.1 主线程的概念："></a>6.1 主线程的概念：</h3><p><code>一个应用程序在启动运行后，系统会自动开启1条线程，这条称为”主线程”。</code></p>
<h3 id="6-2-主线程的作用："><a href="#6-2-主线程的作用：" class="headerlink" title="6.2 主线程的作用："></a>6.2 主线程的作用：</h3><p><code>主线程的作用主要用于处理UI界面刷新和UI时间！</code></p>
<h3 id="6-3-结论："><a href="#6-3-结论：" class="headerlink" title="6.3 结论："></a>6.3 结论：</h3><p> <code>主线程上不能执行耗时操作，这样会造成界面卡顿，给用户一种不好的体验。</code></p>
<h2 id="7、技术方案"><a href="#7、技术方案" class="headerlink" title="7、技术方案"></a>7、技术方案</h2><p>
        <span class="lazyload-img-span">
        <img   
           data-src="https://upload-images.jianshu.io/upload_images/1442184-958d37ecd73c1caf.jpg" >
        </sapn>
      </p>
<hr>
<h1 id="二、Pthread"><a href="#二、Pthread" class="headerlink" title="二、Pthread"></a>二、Pthread</h1><h2 id="1、函数"><a href="#1、函数" class="headerlink" title="1、函数"></a></a>1、函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread_create(pthread_t *restrict, const pthread_attr_t *restrict, void _(_)(void *), void *restrict)</span><br></pre></td></tr></table></figure>


<h2 id="2、参数和返回值"><a href="#2、参数和返回值" class="headerlink" title="2、参数和返回值"></a>2、参数和返回值</h2><ul>
<li><p><code>pthread_t *restrict</code> 线程编号的地址</p>
</li>
<li><p><code>const pthread_attr_t *restrict</code> 线程的属性</p>
</li>
<li><p><code>void *(*)(void *)</code> 线程要执行的函数</p>
</li>
<li><p><code>int * </code>指向<code>int</code>类型的指针<code> void *</code> 指向任何类型的指针 有点类似OC中的<code>id</code></p>
</li>
<li><p><code>void *restrict </code>要执行的函数的参数</p>
</li>
<li><p>返回值<code>int</code>类型 0是成功 非0 是失败</p>
</li>
</ul>
<h2 id="3、使用"><a href="#3、使用" class="headerlink" title="3、使用"></a>3、使用</h2><p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"># import &lt;pthread/pthread.h&gt;</span><br><span class="line"></span><br><span class="line">void *demo(void *param) &#123;</span><br><span class="line">    NSString *name = (__bridge NSString *)(param);</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;hello %@ %@&quot;,name,[NSThread currentThread]);</span><br><span class="line">    return NULL;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        //创建子线程</span><br><span class="line">        pthread_t pthread; //线程编号</span><br><span class="line">        </span><br><span class="line">        NSString *test = @&quot;test&quot;;</span><br><span class="line">        int result =  pthread_create(&amp;pthread, NULL, demo, (__bridge void *)(test));</span><br><span class="line">        NSLog(@&quot;Began  %@&quot;,[NSThread currentThread]);</span><br><span class="line">        </span><br><span class="line">        if (result == 0) &#123;</span><br><span class="line">            NSLog(@&quot;成功&quot;);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            NSLog(@&quot;失败&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>控制台</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2016-02-16 22:00:57.401 Test[888:42585] Began &lt;NSThread: 0x100502d70&gt;&#123;number = 1, name = main&#125;  </span><br><span class="line">2016-02-16 22:00:57.403 Test[888:42615] hello test &lt;NSThread: 0x100102a30&gt;&#123;number = 2, name = (null)&#125;  </span><br><span class="line">2016-02-16 22:00:57.403 Test[888:42585] 成功</span><br></pre></td></tr></table></figure>


<blockquote>
<ul>
<li><code>__bridge 桥接</code>，把OC中的对象，传递给c语言的函数，使用<code>__bridge</code></li>
</ul>
</blockquote>
<hr>
<h1 id="三、NSThread"><a href="#三、NSThread" class="headerlink" title="三、NSThread"></a>三、NSThread</h1><h2 id="1、创建一个新的线程"><a href="#1、创建一个新的线程" class="headerlink" title="1、创建一个新的线程"></a>1、创建一个新的线程</h2><ul>
<li><h3 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h3></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(demo) object:nil];</span><br></pre></td></tr></table></figure>

<ul>
<li><h3 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h3></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[NSThread detachNewThreadSelector:@selector(demo) toTarget:self withObject:nil];</span><br></pre></td></tr></table></figure>


<ul>
<li><h3 id="方式三"><a href="#方式三" class="headerlink" title="方式三"></a>方式三</h3></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self performSelectorInBackground:@selector(demo) withObject:nil];</span><br></pre></td></tr></table></figure>


<h2 id="2、线程的状态"><a href="#2、线程的状态" class="headerlink" title="2、线程的状态"></a>2、线程的状态</h2><h3 id="线程状态分为五种"><a href="#线程状态分为五种" class="headerlink" title="线程状态分为五种"></a>线程状态分为五种</h3><ul>
<li><p>创建 New</p>
</li>
<li><p>就绪 Runnable</p>
</li>
<li><p>运行 Running</p>
<ul>
<li><code> (void)start;</code></li>
</ul>
</li>
<li><p>阻塞（暂停） Blocked</p>
<ul>
<li><code>(void)sleepUntilDate:(NSDate *)date;</code></li>
<li><code>(void)sleepForTimeInterval:(NSTimeInterval)ti;</code></li>
</ul>
</li>
<li><p>死亡 Dead</p>
<ul>
<li><code>(void)exit;</code></li>
</ul>
</li>
</ul>
<h2 id="3、线程的属性"><a href="#3、线程的属性" class="headerlink" title="3、线程的属性"></a>3、线程的属性</h2><p><strong><code>线程有两个重要的属性：名称和优先级</code></strong></p>
<h3 id="3-1-名称-name"><a href="#3-1-名称-name" class="headerlink" title="3.1 名称 name"></a>3.1 名称 name</h3><p><strong>设置线程名用于记录线程，在出现异常时可以DeBug</strong></p>
<h3 id="3-2-优先级，也叫做“服务质量”。threadPriority，取值0到1"><a href="#3-2-优先级，也叫做“服务质量”。threadPriority，取值0到1" class="headerlink" title="3.2 优先级，也叫做“服务质量”。threadPriority，取值0到1."></a>3.2 优先级，也叫做“服务质量”。<code>threadPriority</code>，取值0到1.</h3><p><strong>优先级或者服务质量高的，可以优先调用，只是说会优先调用，但是不是百分之百的优先调用，这里存在一个概率问题，内核里的算法调度线程的时候，只是把优先级作为一个考虑因素，还有很多个因数会决定哪个线程优先调用。这点得注意注意！！！</strong></p>
<p>下面是测试代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">    //新建状态</span><br><span class="line">    NSThread *test1 = [[NSThread alloc] initWithTarget:self selector:@selector(demo) object:nil];</span><br><span class="line">    test1.name = @&quot;test1&quot;;</span><br><span class="line">    //线程的优先级</span><br><span class="line">    test1.threadPriority = 1.0;</span><br><span class="line">    //就绪状态</span><br><span class="line">    [test1 start];</span><br><span class="line">    </span><br><span class="line">    //新建状态</span><br><span class="line">    NSThread *test2= [[NSThread alloc] initWithTarget:self selector:@selector(demo) object:nil];</span><br><span class="line">    test2.name = @&quot;test2&quot;;</span><br><span class="line">    test2.threadPriority = 0;</span><br><span class="line">    //就绪状态</span><br><span class="line">    [test2 start];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//线程执行完成之后会自动销毁</span><br><span class="line"></span><br><span class="line">- (void)demo &#123;</span><br><span class="line">    for (int i = 0; i &lt; 20; i++) &#123;</span><br><span class="line">        NSLog(@&quot;%d--%@&quot;,i,[NSThread currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>控制台</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">2016-02-16 22:43:28.182 05-线程状态[1241:78688] 0--&lt;NSThread: 0x7fead2017f30&gt;&#123;number = 2, name = test1&#125;  </span><br><span class="line">2016-02-16 22:43:28.182 05-线程状态[1241:78689] 0--&lt;NSThread: 0x7fead050a250&gt;&#123;number = 3, name = test2&#125;  </span><br><span class="line">2016-02-16 22:43:28.182 05-线程状态[1241:78688] 1--&lt;NSThread: 0x7fead2017f30&gt;&#123;number = 2, name = test1&#125;  </span><br><span class="line">2016-02-16 22:43:28.182 05-线程状态[1241:78688] 2--&lt;NSThread: 0x7fead2017f30&gt;&#123;number = 2, name = test1&#125;  </span><br><span class="line">2016-02-16 22:43:28.182 05-线程状态[1241:78689] 1--&lt;NSThread: 0x7fead050a250&gt;&#123;number = 3, name = test2&#125;  </span><br><span class="line">2016-02-16 22:43:28.183 05-线程状态[1241:78688] 3--&lt;NSThread: 0x7fead2017f30&gt;&#123;number = 2, name = test1&#125;  </span><br><span class="line">2016-02-16 22:43:28.183 05-线程状态[1241:78689] 2--&lt;NSThread: 0x7fead050a250&gt;&#123;number = 3, name = test2&#125;  </span><br><span class="line">2016-02-16 22:43:28.183 05-线程状态[1241:78688] 4--&lt;NSThread: 0x7fead2017f30&gt;&#123;number = 2, name = test1&#125;  </span><br><span class="line">2016-02-16 22:43:28.183 05-线程状态[1241:78688] 5--&lt;NSThread: 0x7fead2017f30&gt;&#123;number = 2, name = test1&#125;  </span><br><span class="line">2016-02-16 22:43:28.183 05-线程状态[1241:78689] 3--&lt;NSThread: 0x7fead050a250&gt;&#123;number = 3, name = test2&#125;  </span><br><span class="line">2016-02-16 22:43:28.183 05-线程状态[1241:78688] 6--&lt;NSThread: 0x7fead2017f30&gt;&#123;number = 2, name = test1&#125;  </span><br><span class="line">2016-02-16 22:43:28.183 05-线程状态[1241:78688] 7--&lt;NSThread: 0x7fead2017f30&gt;&#123;number = 2, name = test1&#125;  </span><br><span class="line">2016-02-16 22:43:28.183 05-线程状态[1241:78689] 4--&lt;NSThread: 0x7fead050a250&gt;&#123;number = 3, name = test2&#125;  </span><br><span class="line">2016-02-16 22:43:28.183 05-线程状态[1241:78688] 8--&lt;NSThread: 0x7fead2017f30&gt;&#123;number = 2, name = test1&#125;  </span><br><span class="line">2016-02-16 22:43:28.184 05-线程状态[1241:78688] 9--&lt;NSThread: 0x7fead2017f30&gt;&#123;number = 2, name = test1&#125;  </span><br><span class="line">2016-02-16 22:43:28.184 05-线程状态[1241:78688] 10--&lt;NSThread: 0x7fead2017f30&gt;&#123;number = 2, name = test1&#125;  </span><br><span class="line">2016-02-16 22:43:28.184 05-线程状态[1241:78689] 5--&lt;NSThread: 0x7fead050a250&gt;&#123;number = 3, name = test2&#125;  </span><br><span class="line">2016-02-16 22:43:28.184 05-线程状态[1241:78688] 11--&lt;NSThread: 0x7fead2017f30&gt;&#123;number = 2, name = test1&#125;  </span><br><span class="line">2016-02-16 22:43:28.184 05-线程状态[1241:78689] 6--&lt;NSThread: 0x7fead050a250&gt;&#123;number = 3, name = test2&#125;  </span><br><span class="line">2016-02-16 22:43:28.184 05-线程状态[1241:78688] 12--&lt;NSThread: 0x7fead2017f30&gt;&#123;number = 2, name = test1&#125;  </span><br><span class="line">2016-02-16 22:43:28.184 05-线程状态[1241:78688] 13--&lt;NSThread: 0x7fead2017f30&gt;&#123;number = 2, name = test1&#125;  </span><br><span class="line">2016-02-16 22:43:28.184 05-线程状态[1241:78689] 7--&lt;NSThread: 0x7fead050a250&gt;&#123;number = 3, name = test2&#125;  </span><br><span class="line">2016-02-16 22:43:28.184 05-线程状态[1241:78688] 14--&lt;NSThread: 0x7fead2017f30&gt;&#123;number = 2, name = test1&#125;  </span><br><span class="line">2016-02-16 22:43:28.184 05-线程状态[1241:78688] 15--&lt;NSThread: 0x7fead2017f30&gt;&#123;number = 2, name = test1&#125;  </span><br><span class="line">2016-02-16 22:43:28.185 05-线程状态[1241:78688] 16--&lt;NSThread: 0x7fead2017f30&gt;&#123;number = 2, name = test1&#125;  </span><br><span class="line">2016-02-16 22:43:28.184 05-线程状态[1241:78689] 8--&lt;NSThread: 0x7fead050a250&gt;&#123;number = 3, name = test2&#125;  </span><br><span class="line">2016-02-16 22:43:28.185 05-线程状态[1241:78688] 17--&lt;NSThread: 0x7fead2017f30&gt;&#123;number = 2, name = test1&#125;  </span><br><span class="line">2016-02-16 22:43:28.185 05-线程状态[1241:78688] 18--&lt;NSThread: 0x7fead2017f30&gt;&#123;number = 2, name = test1&#125;  </span><br><span class="line">2016-02-16 22:43:28.185 05-线程状态[1241:78689] 9--&lt;NSThread: 0x7fead050a250&gt;&#123;number = 3, name = test2&#125;  </span><br><span class="line">2016-02-16 22:43:28.185 05-线程状态[1241:78688] 19--&lt;NSThread: 0x7fead2017f30&gt;&#123;number = 2, name = test1&#125;  </span><br><span class="line">2016-02-16 22:43:28.185 05-线程状态[1241:78689] 10--&lt;NSThread: 0x7fead050a250&gt;&#123;number = 3, name = test2&#125;  </span><br><span class="line">2016-02-16 22:43:28.186 05-线程状态[1241:78689] 11--&lt;NSThread: 0x7fead050a250&gt;&#123;number = 3, name = test2&#125;  </span><br><span class="line">2016-02-16 22:43:28.186 05-线程状态[1241:78689] 12--&lt;NSThread: 0x7fead050a250&gt;&#123;number = 3, name = test2&#125;  </span><br><span class="line">2016-02-16 22:43:28.186 05-线程状态[1241:78689] 13--&lt;NSThread: 0x7fead050a250&gt;&#123;number = 3, name = test2&#125;  </span><br><span class="line">2016-02-16 22:43:28.186 05-线程状态[1241:78689] 14--&lt;NSThread: 0x7fead050a250&gt;&#123;number = 3, name = test2&#125;  </span><br><span class="line">2016-02-16 22:43:28.187 05-线程状态[1241:78689] 15--&lt;NSThread: 0x7fead050a250&gt;&#123;number = 3, name = test2&#125;  </span><br><span class="line">2016-02-16 22:43:28.187 05-线程状态[1241:78689] 16--&lt;NSThread: 0x7fead050a250&gt;&#123;number = 3, name = test2&#125;  </span><br><span class="line">2016-02-16 22:43:28.187 05-线程状态[1241:78689] 17--&lt;NSThread: 0x7fead050a250&gt;&#123;number = 3, name = test2&#125;  </span><br><span class="line">2016-02-16 22:43:28.187 05-线程状态[1241:78689] 18--&lt;NSThread: 0x7fead050a250&gt;&#123;number = 3, name = test2&#125;  </span><br><span class="line">2016-02-16 22:43:28.187 05-线程状态[1241:78689] 19--&lt;NSThread: 0x7fead050a250&gt;&#123;number = 3, name = test2&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>结论：优先级高，不一定先执行，只能说明先执行的概率要大一些！！！</code></p>
</blockquote>
<hr>
<h1 id="四、互斥锁"><a href="#四、互斥锁" class="headerlink" title="四、互斥锁"></a>四、互斥锁</h1><h2 id="1、访问共享资源引入问题！"><a href="#1、访问共享资源引入问题！" class="headerlink" title="1、访问共享资源引入问题！"></a>1、访问共享资源引入问题！</h2><h3 id="1-1-问题？"><a href="#1-1-问题？" class="headerlink" title="1.1 问题？"></a>1.1 问题？</h3><p> <code>不同的线程要访问共享的资源，而且对共享的资源做操作，由于上面结论得出服务质量和优先级不能决定线程执行的先后顺序，那么问题来了，一个线程对共享资源做了修改，而另外一个线程拿到的是未被修改之前资源，这是这个线程也对该资源做了修改，现在请问，两个线程都对该资源做了不同的修改，那么这个修改应该算谁的？！？！这就是问题所在！！！</code></p>
<h3 id="1-2-问题分析"><a href="#1-2-问题分析" class="headerlink" title="1.2 问题分析"></a>1.2 问题分析</h3><p>
        <span class="lazyload-img-span">
        <img   
           data-src="https://upload-images.jianshu.io/upload_images/1442184-988b8cc8226a4ebd.jpg" >
        </sapn>
      </p>
<h3 id="1-3-问题解决"><a href="#1-3-问题解决" class="headerlink" title="1.3 问题解决"></a>1.3 问题解决</h3><p>
        <span class="lazyload-img-span">
        <img   
           data-src="https://upload-images.jianshu.io/upload_images/1442184-01f1a111e45054ac.jpg" >
        </sapn>
      </p>
<p> <code>解决方案很简单，就是用一把锁锁住共享资源，等待线程1对其操作完毕后再打开，让线程2来执行，这就是传说中的互斥锁</code>！！！</p>
<h2 id="2、互斥锁介绍"><a href="#2、互斥锁介绍" class="headerlink" title="2、互斥锁介绍"></a><a id="2、互斥锁介绍"></a>2、互斥锁介绍</h2><h3 id="2-1-互斥锁代码"><a href="#2-1-互斥锁代码" class="headerlink" title="2.1 互斥锁代码"></a>2.1 互斥锁代码</h3><p><code>@synchronized(锁对象) &#123; 需要锁定的代码 &#125;</code></p>
<h3 id="2-2-互斥锁的作用"><a href="#2-2-互斥锁的作用" class="headerlink" title="2.2 互斥锁的作用"></a>2.2 互斥锁的作用</h3><p><code>可以防止因多线程执行顺序不定导致的抢夺资源造成的数据安全的问题</code></p>
<h3 id="2-3-真相："><a href="#2-3-真相：" class="headerlink" title="2.3 真相："></a>2.3 真相：</h3><p><code>互斥锁其实就是同步的意思，也就是按顺序执行！</code></p>
<h2 id="3、互斥锁原理"><a href="#3、互斥锁原理" class="headerlink" title="3、互斥锁原理"></a>3、互斥锁原理</h2><p><code>每个NSObject对象内部都有一把锁，当线程要进入synchronized到对象的时候就要判断，锁是否被打开，如果打开，进入执行，如果锁住，继续等待，这就是互斥锁的原理！</code></p>
<h2 id="4、互斥锁和自旋锁"><a href="#4、互斥锁和自旋锁" class="headerlink" title="4、互斥锁和自旋锁"></a>4、互斥锁和自旋锁</h2><p><code>自旋锁就是atomic！</code></p>
<h3 id="4-1-原子属性和非原子属性（nonatomic-和-atomic）"><a href="#4-1-原子属性和非原子属性（nonatomic-和-atomic）" class="headerlink" title="4.1 原子属性和非原子属性（nonatomic 和 atomic）"></a>4.1 原子属性和非原子属性（<code>nonatomic</code> 和 <code>atomic</code>）</h3><ul>
<li><code>nonatomic</code>:非原子属性，不会为 setter 方法加锁。</li>
<li><code>atomic</code>: 原子属性，为 setter 方法加锁(默认就是atomic)。</li>
<li>通过给 setter 加锁，可以保证同一时间只有一个线程能够执行写入操作(setter)，但是同一时间允许多个线程执行读取操作(getter)。<code>atomic</code>本身就有一把自旋锁。<br>这个特点叫做”单写多读”: 单个线程写入，多个线程读取。</li>
<li><code> atomic</code> 只能保证写入数据的时候是安全的，但不能保证同时读写的时候是安全的。所以，不常使用！</li>
</ul>
<h3 id="4-2-nonatomic-和-atomic-的对比"><a href="#4-2-nonatomic-和-atomic-的对比" class="headerlink" title="4.2 nonatomic 和 atomic 的对比"></a>4.2 <code>nonatomic</code> 和 <code>atomic</code> 的对比</h3><ul>
<li><p><code>atomic</code>：线程安全(执行setter方法的时候)，需要消耗大量的资源。</p>
</li>
<li><p><code>nonatomic</code>：非线程安全，适合内存小的移动设备。</p>
</li>
</ul>
<h3 id="4-3-互斥锁和自旋锁的区别"><a href="#4-3-互斥锁和自旋锁的区别" class="headerlink" title="4.3 互斥锁和自旋锁的区别"></a>4.3 互斥锁和自旋锁的区别</h3><h4 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h4><p><code>如果发现其它线程正在执行锁定代码，线程会进入休眠(阻塞状态)，等其它线程时间片到了打开锁后，线程就会被唤醒(执行)。</code></p>
<h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><p><code>如果发现有其它线程正在执行锁定代码，线程会以死循环的方式，一直等待锁定的代码执行完成。</code></p>
<hr>
<h1 id="五、GCD"><a href="#五、GCD" class="headerlink" title="五、GCD"></a>五、GCD</h1><h2 id="1、GCD介绍"><a href="#1、GCD介绍" class="headerlink" title="1、GCD介绍"></a>1、GCD介绍</h2><blockquote>
<p>全称<code>Grand Central Dispatch</code>,可翻译为”牛逼的中枢调度器”</p>
<p>纯C语言开发，是苹果公司为多核的并行运算提出的解决方案，会自动利用更多的CPU内核（比如双核、四核），可以自动管理线程的生命周期（创建线程、调度任务、销毁线程）。</p>
</blockquote>
<h2 id="2、GCD的两个核心"><a href="#2、GCD的两个核心" class="headerlink" title="2、GCD的两个核心"></a><a id="2、GCD的两个核心"></a>2、GCD的两个核心</h2><h3 id="2-1-任务"><a href="#2-1-任务" class="headerlink" title="2.1 任务"></a>2.1 任务</h3><ul>
<li>执行的操作,在GCD中，任务是通过 block来封装的。并且任务的block没有参数也没有返回值。</li>
</ul>
<h3 id="2-2-队列"><a href="#2-2-队列" class="headerlink" title="2.2 队列"></a>2.2 队列</h3><ul>
<li>存放任务</li>
</ul>
<h4 id="包括"><a href="#包括" class="headerlink" title="包括"></a>包括</h4><ul>
<li>串行队列</li>
<li>并发队列</li>
<li>主队列</li>
<li>全局队列</li>
</ul>
<p>队列的类型</p>
<p>
        <span class="lazyload-img-span">
        <img   
           data-src="https://upload-images.jianshu.io/upload_images/1442184-aea71e89d504e051.jpg" >
        </sapn>
      </p>
<h2 id="3、函数"><a href="#3、函数" class="headerlink" title="3、函数"></a>3、函数</h2><h3 id="3-1-GCD函数"><a href="#3-1-GCD函数" class="headerlink" title="3.1 GCD函数"></a>3.1 GCD函数</h3><h4 id="3-1-1-同步-dispatch-sync"><a href="#3-1-1-同步-dispatch-sync" class="headerlink" title="3.1.1 同步 dispatch_sync"></a>3.1.1 同步 <code>dispatch_sync</code></h4><h5 id="同步：任务会在当前线程执行，因为同步函数不具备开新线程的能力。"><a href="#同步：任务会在当前线程执行，因为同步函数不具备开新线程的能力。" class="headerlink" title="同步：任务会在当前线程执行，因为同步函数不具备开新线程的能力。"></a>同步：任务会在当前线程执行，因为同步函数不具备开新线程的能力。</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);</span><br></pre></td></tr></table></figure>


<h4 id="3-1-2-异步-dispatch-async"><a href="#3-1-2-异步-dispatch-async" class="headerlink" title="3.1.2 异步 dispatch_async"></a>3.1.2 异步 <code>dispatch_async</code></h4><h5 id="异步：任务会在子线程执行，因为异步函数具备开新线程的能力。"><a href="#异步：任务会在子线程执行，因为异步函数具备开新线程的能力。" class="headerlink" title="异步：任务会在子线程执行，因为异步函数具备开新线程的能力。"></a>异步：任务会在子线程执行，因为异步函数具备开新线程的能力。</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void dispatch_async(dispatch_queue_t queue, dispatch_block_t block);</span><br></pre></td></tr></table></figure>


<h3 id="3-2-GCD使用步骤"><a href="#3-2-GCD使用步骤" class="headerlink" title="3.2 GCD使用步骤:"></a>3.2 GCD使用步骤:</h3><ul>
<li>创建队列，或则获取队列</li>
<li>创建任务</li>
<li>将任务添加到队列中</li>
<li>GCD会自动将队列中的任务取出，放到对应的线程中执行</li>
<li>任务取出遵循队列的FIFO原则：先进先出，后进后出</li>
</ul>
<p>示例代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 1\. 获取全局队列</span><br><span class="line"></span><br><span class="line">dispatch_queue_t queue = dispatch_get_global_queue(0, 0);</span><br><span class="line">// 2\. 创建任务</span><br><span class="line">dispatch_block_t task = ^ &#123;</span><br><span class="line">    NSLog(@&quot;hello %@&quot;, [NSThread currentThread]);</span><br><span class="line">&#125;;</span><br><span class="line">// 3\. 将任务添加到队列，并且指定执行任务的函数</span><br><span class="line">dispatch_async(queue, task);</span><br></pre></td></tr></table></figure>
<p> 通常写成一句代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;  </span><br><span class="line">    NSLog(@&quot;hello %@&quot;, [NSThread currentThread]);  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<h2 id="4、串行队列和并发队列"><a href="#4、串行队列和并发队列" class="headerlink" title="4、串行队列和并发队列"></a>4、串行队列和并发队列</h2><h3 id="4-1-串行队列-Serial-Dispatch-Queue"><a href="#4-1-串行队列-Serial-Dispatch-Queue" class="headerlink" title="4.1 串行队列 Serial Dispatch Queue"></a>4.1 串行队列 <code>Serial Dispatch Queue</code></h3><h4 id="4-1-1-特点"><a href="#4-1-1-特点" class="headerlink" title="4.1.1 特点"></a>4.1.1 特点</h4><ul>
<li><code>先进先出，按照顺序执行,并且一次只能调用一个任务</code></li>
<li><code>无论队列中所指定的执行任务的函数是同步还是异步，都必须等待前一个任务执行完毕才可以调用后面的人</code></li>
</ul>
<h4 id="4-1-2-创建一个串行队列"><a href="#4-1-2-创建一个串行队列" class="headerlink" title="4.1.2 创建一个串行队列"></a>4.1.2 创建一个串行队列</h4><ul>
<li>方法一</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;test&quot;, DISPATCH_QUEUE_SERIAL);</span><br></pre></td></tr></table></figure>


<ul>
<li>方法二</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;test&quot;, NULL);</span><br></pre></td></tr></table></figure>


<h4 id="4-1-3-串行队列，同步执行"><a href="#4-1-3-串行队列，同步执行" class="headerlink" title="4.1.3 串行队列，同步执行"></a>4.1.3 串行队列，同步执行</h4><p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 1、创建串行队列</span><br><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;test&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">// 2、将任务添加到队列，并且指定同步执行</span><br><span class="line">for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;%@--%d&quot;,[NSThread currentThread],i);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">2016-02-25 16:31:07.849 test[1924:376468] &lt;NSThread: 0x7ff040404370&gt;&#123;number = 1, name = main&#125;--0  </span><br><span class="line">2016-02-25 16:31:07.849 test[1924:376468] &lt;NSThread: 0x7ff040404370&gt;&#123;number = 1, name = main&#125;--1  </span><br><span class="line">2016-02-25 16:31:07.849 test[1924:376468] &lt;NSThread: 0x7ff040404370&gt;&#123;number = 1, name = main&#125;--2  </span><br><span class="line">2016-02-25 16:31:07.849 test[1924:376468] &lt;NSThread: 0x7ff040404370&gt;&#123;number = 1, name = main&#125;--3  </span><br><span class="line">2016-02-25 16:31:07.849 test[1924:376468] &lt;NSThread: 0x7ff040404370&gt;&#123;number = 1, name = main&#125;--4  </span><br><span class="line">2016-02-25 16:31:07.849 test[1924:376468] &lt;NSThread: 0x7ff040404370&gt;&#123;number = 1, name = main&#125;--5  </span><br><span class="line">2016-02-25 16:31:07.850 test[1924:376468] &lt;NSThread: 0x7ff040404370&gt;&#123;number = 1, name = main&#125;--6  </span><br><span class="line">2016-02-25 16:31:07.850 test[1924:376468] &lt;NSThread: 0x7ff040404370&gt;&#123;number = 1, name = main&#125;--7  </span><br><span class="line">2016-02-25 16:31:07.850 test[1924:376468] &lt;NSThread: 0x7ff040404370&gt;&#123;number = 1, name = main&#125;--8  </span><br><span class="line">2016-02-25 16:31:07.850 test[1924:376468] &lt;NSThread: 0x7ff040404370&gt;&#123;number = 1, name = main&#125;--9</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>结论：串行队列，同步执行，不开新线程，按顺序执行</code></p>
</blockquote>
<h4 id="4-1-4-串行队列，异步执行"><a href="#4-1-4-串行队列，异步执行" class="headerlink" title="4.1.4 串行队列，异步执行"></a>4.1.4 串行队列，异步执行</h4><p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 1、创建串行队列</span><br><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;test&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">// 2、将任务添加到队列，并且指定同步执行</span><br><span class="line">for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;%@--%d&quot;,[NSThread currentThread],i);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">2016-02-25 17:08:32.167 test[1959:391722] &lt;NSThread: 0x7fbb98d24fa0&gt;&#123;number = 2, name = (null)&#125;--0  </span><br><span class="line">2016-02-25 17:08:32.168 test[1959:391722] &lt;NSThread: 0x7fbb98d24fa0&gt;&#123;number = 2, name = (null)&#125;--1  </span><br><span class="line">2016-02-25 17:08:32.168 test[1959:391722] &lt;NSThread: 0x7fbb98d24fa0&gt;&#123;number = 2, name = (null)&#125;--2  </span><br><span class="line">2016-02-25 17:08:32.168 test[1959:391722] &lt;NSThread: 0x7fbb98d24fa0&gt;&#123;number = 2, name = (null)&#125;--3  </span><br><span class="line">2016-02-25 17:08:32.168 test[1959:391722] &lt;NSThread: 0x7fbb98d24fa0&gt;&#123;number = 2, name = (null)&#125;--4  </span><br><span class="line">2016-02-25 17:08:32.168 test[1959:391722] &lt;NSThread: 0x7fbb98d24fa0&gt;&#123;number = 2, name = (null)&#125;--5  </span><br><span class="line">2016-02-25 17:08:32.169 test[1959:391722] &lt;NSThread: 0x7fbb98d24fa0&gt;&#123;number = 2, name = (null)&#125;--6  </span><br><span class="line">2016-02-25 17:08:32.169 test[1959:391722] &lt;NSThread: 0x7fbb98d24fa0&gt;&#123;number = 2, name = (null)&#125;--7  </span><br><span class="line">2016-02-25 17:08:32.169 test[1959:391722] &lt;NSThread: 0x7fbb98d24fa0&gt;&#123;number = 2, name = (null)&#125;--8  </span><br><span class="line">2016-02-25 17:08:32.169 test[1959:391722] &lt;NSThread: 0x7fbb98d24fa0&gt;&#123;number = 2, name = (null)&#125;--9</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>结论：串行队列，异步执行，开启一条新的线程，按顺序执行</code></p>
</blockquote>
<h3 id="4-2-并发队列-Concurrent-Dispatch-Queue"><a href="#4-2-并发队列-Concurrent-Dispatch-Queue" class="headerlink" title="4.2 并发队列 Concurrent Dispatch Queue"></a>4.2 并发队列 <code>Concurrent Dispatch Queue</code></h3><h4 id="4-2-1-特点"><a href="#4-2-1-特点" class="headerlink" title="4.2.1 特点"></a>4.2.1 特点</h4><ul>
<li>并发同时调度队列中的任务去执行</li>
<li>如果当前调度的任务是同步执行的，会等待当前任务执行完毕后，再调度后续的任务</li>
<li>如果当前调度的任务是异步执行的，同时底层线程池有可用的线程资源，就不会等待当前任务，直接调度任务到新线程去执行。</li>
</ul>
<h4 id="4-2-2-创建并发队列"><a href="#4-2-2-创建并发队列" class="headerlink" title="4.2.2 创建并发队列"></a>4.2.2 创建并发队列</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t q = dispatch_queue_create(&quot;test&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br></pre></td></tr></table></figure>


<h4 id="4-2-3-并发队列，同步执行"><a href="#4-2-3-并发队列，同步执行" class="headerlink" title="4.2.3 并发队列，同步执行"></a>4.2.3 并发队列，同步执行</h4><p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 1\. 创建并发队列</span><br><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;test&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">// 2\. 将任务添加到队列, 并且指定同步执行</span><br><span class="line">for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;%@ %d&quot;, [NSThread currentThread], i);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">2016-02-25 17:18:38.039 test[1979:399667] &lt;NSThread: 0x7ffef86024b0&gt;&#123;number = 1, name = main&#125; 0  </span><br><span class="line">2016-02-25 17:18:38.040 test[1979:399667] &lt;NSThread: 0x7ffef86024b0&gt;&#123;number = 1, name = main&#125; 1  </span><br><span class="line">2016-02-25 17:18:38.040 test[1979:399667] &lt;NSThread: 0x7ffef86024b0&gt;&#123;number = 1, name = main&#125; 2  </span><br><span class="line">2016-02-25 17:18:38.040 test[1979:399667] &lt;NSThread: 0x7ffef86024b0&gt;&#123;number = 1, name = main&#125; 3  </span><br><span class="line">2016-02-25 17:18:38.040 test[1979:399667] &lt;NSThread: 0x7ffef86024b0&gt;&#123;number = 1, name = main&#125; 4  </span><br><span class="line">2016-02-25 17:18:38.040 test[1979:399667] &lt;NSThread: 0x7ffef86024b0&gt;&#123;number = 1, name = main&#125; 5  </span><br><span class="line">2016-02-25 17:18:38.040 test[1979:399667] &lt;NSThread: 0x7ffef86024b0&gt;&#123;number = 1, name = main&#125; 6  </span><br><span class="line">2016-02-25 17:18:38.040 test[1979:399667] &lt;NSThread: 0x7ffef86024b0&gt;&#123;number = 1, name = main&#125; 7  </span><br><span class="line">2016-02-25 17:18:38.040 test[1979:399667] &lt;NSThread: 0x7ffef86024b0&gt;&#123;number = 1, name = main&#125; 8  </span><br><span class="line">2016-02-25 17:18:38.041 test[1979:399667] &lt;NSThread: 0x7ffef86024b0&gt;&#123;number = 1, name = main&#125; 9</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>结论:并发队列，同步执行，不开线程，顺序执行</code></p>
</blockquote>
<h4 id="4-2-4-并发队列，异步执行"><a href="#4-2-4-并发队列，异步执行" class="headerlink" title="4.2.4 并发队列，异步执行"></a>4.2.4 并发队列，异步执行</h4><p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 1\. 创建并发队列</span><br><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;test&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">// 2\. 将任务添加到队列, 并且指定同步执行</span><br><span class="line">for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;%@ %d&quot;, [NSThread currentThread], i);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">2016-02-25 17:22:59.357 test[1992:403694] &lt;NSThread: 0x7fe531c1a9b0&gt;&#123;number = 7, name = (null)&#125; 6  </span><br><span class="line">2016-02-25 17:22:59.356 test[1992:403684] &lt;NSThread: 0x7fe531d18fa0&gt;&#123;number = 3, name = (null)&#125; 1  </span><br><span class="line">2016-02-25 17:22:59.356 test[1992:403689] &lt;NSThread: 0x7fe534300610&gt;&#123;number = 5, name = (null)&#125; 3  </span><br><span class="line">2016-02-25 17:22:59.356 test[1992:403683] &lt;NSThread: 0x7fe531e94d80&gt;&#123;number = 2, name = (null)&#125; 0  </span><br><span class="line">2016-02-25 17:22:59.356 test[1992:403692] &lt;NSThread: 0x7fe531e9df80&gt;&#123;number = 6, name = (null)&#125; 4  </span><br><span class="line">2016-02-25 17:22:59.356 test[1992:403693] &lt;NSThread: 0x7fe531d18f40&gt;&#123;number = 8, name = (null)&#125; 5  </span><br><span class="line">2016-02-25 17:22:59.356 test[1992:403695] &lt;NSThread: 0x7fe5343015e0&gt;&#123;number = 9, name = (null)&#125; 7  </span><br><span class="line">2016-02-25 17:22:59.357 test[1992:403688] &lt;NSThread: 0x7fe531c16e30&gt;&#123;number = 4, name = (null)&#125; 2  </span><br><span class="line">2016-02-25 17:22:59.357 test[1992:403694] &lt;NSThread: 0x7fe531c1a9b0&gt;&#123;number = 7, name = (null)&#125; 9  </span><br><span class="line">2016-02-25 17:22:59.357 test[1992:403696] &lt;NSThread: 0x7fe531c237a0&gt;&#123;number = 10, name = (null)&#125; 8</span><br></pre></td></tr></table></figure>


<blockquote>
<p><code>结论：开启足够多的线程，不按照顺序执行CPU在调度的时候以最高效的方式调度和执行任务，所以会开启多条线程，因为并发，执行顺序不一定</code></p>
</blockquote>
<h2 id="5、主队列"><a href="#5、主队列" class="headerlink" title="5、主队列"></a>5、主队列</h2><h3 id="5-1-主队列"><a href="#5-1-主队列" class="headerlink" title="5.1 主队列"></a>5.1 主队列</h3><ul>
<li>主队列是系统提供的，无需自己创建，可以通过<code>dispatch_get_main_queue()</code>函数来获取。</li>
</ul>
<h3 id="5-2-特点"><a href="#5-2-特点" class="headerlink" title="5.2 特点"></a>5.2 特点</h3><ul>
<li>添加到主队列的任务只能由主线程来执行。</li>
<li>先进先出的，只有当主线程的代码执行完毕后，主队列才会调度任务到主线程执行</li>
</ul>
<h3 id="5-3-主队列-异步执行"><a href="#5-3-主队列-异步执行" class="headerlink" title="5.3 主队列 异步执行"></a>5.3 主队列 异步执行</h3><p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 1\. 获取主队列</span><br><span class="line">dispatch_queue_t q = dispatch_get_main_queue();</span><br><span class="line">// 2\. 将任务添加到主队列, 并且指定异步执行</span><br><span class="line">for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    dispatch_async(q, ^&#123;</span><br><span class="line">        NSLog(@&quot;%@ %d&quot;, [NSThread currentThread], i);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">// 先执行完这句代码, 才会执行主队列中的任务</span><br><span class="line">NSLog(@&quot;hello %@&quot;, [NSThread currentThread]);</span><br></pre></td></tr></table></figure>

<p>打印</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">2016-02-25 21:10:43.293 test[773:786816] hello &lt;NSThread: 0x7ff158c05940&gt;&#123;number = 1, name = main&#125;  </span><br><span class="line">2016-02-25 21:10:43.295 test[773:786816] &lt;NSThread: 0x7ff158c05940&gt;&#123;number = 1, name = main&#125; 0  </span><br><span class="line">2016-02-25 21:10:43.295 test[773:786816] &lt;NSThread: 0x7ff158c05940&gt;&#123;number = 1, name = main&#125; 1  </span><br><span class="line">2016-02-25 21:10:43.296 test[773:786816] &lt;NSThread: 0x7ff158c05940&gt;&#123;number = 1, name = main&#125; 2  </span><br><span class="line">2016-02-25 21:10:43.296 test[773:786816] &lt;NSThread: 0x7ff158c05940&gt;&#123;number = 1, name = main&#125; 3  </span><br><span class="line">2016-02-25 21:10:43.296 test[773:786816] &lt;NSThread: 0x7ff158c05940&gt;&#123;number = 1, name = main&#125; 4  </span><br><span class="line">2016-02-25 21:10:43.296 test[773:786816] &lt;NSThread: 0x7ff158c05940&gt;&#123;number = 1, name = main&#125; 5  </span><br><span class="line">2016-02-25 21:10:43.296 test[773:786816] &lt;NSThread: 0x7ff158c05940&gt;&#123;number = 1, name = main&#125; 6  </span><br><span class="line">2016-02-25 21:10:43.296 test[773:786816] &lt;NSThread: 0x7ff158c05940&gt;&#123;number = 1, name = main&#125; 7  </span><br><span class="line">2016-02-25 21:10:43.296 test[773:786816] &lt;NSThread: 0x7ff158c05940&gt;&#123;number = 1, name = main&#125; 8  </span><br><span class="line">2016-02-25 21:10:43.296 test[773:786816] &lt;NSThread: 0x7ff158c05940&gt;&#123;number = 1, name = main&#125; 9</span><br></pre></td></tr></table></figure>


<p>打印结果得出的一些结论</p>
<ul>
<li>在主线程顺序执行，不开启新的线程</li>
<li>主队列的特点：只有当主线程空闲时，主队列才会调度任务到主线程执行</li>
<li>主队列就算是异步执行也不会开启新的线程</li>
<li>主队列相当于一个全局的串行队列</li>
<li>主队列和串行队列的区别</li>
<li>串行队列:必须等待一个任务执行完毕，才会调度下一个任务。</li>
<li>主队列:如果主线程上有代码执行，主队列就不调度任务。</li>
</ul>
<h3 id="5-4-主队列-同步执行（死锁）"><a href="#5-4-主队列-同步执行（死锁）" class="headerlink" title="5.4 主队列 同步执行（死锁）"></a>5.4 主队列 同步执行（死锁）</h3><p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@&quot;begin&quot;);</span><br><span class="line">// 1\. 获取主队列</span><br><span class="line">dispatch_queue_t q = dispatch_get_main_queue();</span><br><span class="line">// 2\. 将任务添加到主队列, 并且指定同步执行</span><br><span class="line">// 死锁</span><br><span class="line">for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    dispatch_sync(q, ^&#123;</span><br><span class="line">        NSLog(@&quot;%@ %d&quot;, [NSThread currentThread], i);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">NSLog(@&quot;end&quot;);</span><br></pre></td></tr></table></figure>


<p>打印</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2016-02-25 21:19:25.986 test[791:790967] begin</span><br></pre></td></tr></table></figure>


<p><code>打印结果可以看出，不是想要的结果，这时候发生了死锁，在主线程执行，主队列同步执行任务，会发生死锁，主线程和主队列同步任务相互等待，造成死锁</code></p>
<h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@&quot;begin&quot;);</span><br><span class="line">dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">    NSLog(@&quot;--- %@&quot;, [NSThread currentThread]);</span><br><span class="line">    // 1\. 获取主队列</span><br><span class="line">    dispatch_queue_t q = dispatch_get_main_queue();</span><br><span class="line">    // 2\. 将任务添加到主队列, 并且指定同步执行</span><br><span class="line">    // 死锁</span><br><span class="line">    for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">        dispatch_sync(q, ^&#123;</span><br><span class="line">            NSLog(@&quot;%@ %d&quot;, [NSThread currentThread], i);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">NSLog(@&quot;end&quot;);</span><br></pre></td></tr></table></figure>


<p>打印</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">2016-02-25 21:23:23.205 test[803:794826] begin  </span><br><span class="line">2016-02-25 21:23:23.206 test[803:794826] end  </span><br><span class="line">2016-02-25 21:23:23.206 test[803:794866] --- &lt;NSThread: 0x7f8830514cb0&gt;&#123;number = 2, name = (null)&#125;  </span><br><span class="line">2016-02-25 21:23:23.209 test[803:794826] &lt;NSThread: 0x7f8830507dd0&gt;&#123;number = 1, name = main&#125; 0  </span><br><span class="line">2016-02-25 21:23:23.209 test[803:794826] &lt;NSThread: 0x7f8830507dd0&gt;&#123;number = 1, name = main&#125; 1  </span><br><span class="line">2016-02-25 21:23:23.209 test[803:794826] &lt;NSThread: 0x7f8830507dd0&gt;&#123;number = 1, name = main&#125; 2  </span><br><span class="line">2016-02-25 21:23:23.209 test[803:794826] &lt;NSThread: 0x7f8830507dd0&gt;&#123;number = 1, name = main&#125; 3  </span><br><span class="line">2016-02-25 21:23:23.209 test[803:794826] &lt;NSThread: 0x7f8830507dd0&gt;&#123;number = 1, name = main&#125; 4  </span><br><span class="line">2016-02-25 21:23:23.210 test[803:794826] &lt;NSThread: 0x7f8830507dd0&gt;&#123;number = 1, name = main&#125; 5  </span><br><span class="line">2016-02-25 21:23:23.210 test[803:794826] &lt;NSThread: 0x7f8830507dd0&gt;&#123;number = 1, name = main&#125; 6  </span><br><span class="line">2016-02-25 21:23:23.210 test[803:794826] &lt;NSThread: 0x7f8830507dd0&gt;&#123;number = 1, name = main&#125; 7  </span><br><span class="line">2016-02-25 21:23:23.210 test[803:794826] &lt;NSThread: 0x7f8830507dd0&gt;&#123;number = 1, name = main&#125; 8  </span><br><span class="line">2016-02-25 21:23:23.210 test[803:794826] &lt;NSThread: 0x7f8830507dd0&gt;&#123;number = 1, name = main&#125; 9</span><br></pre></td></tr></table></figure>


<p><code>打印结果可以看出，当我们将主队列同步执行任务放到子线程去执行，就不会出现死锁。由于将主队列同步放到了子线程中执行，主队列同步任务无法阻塞主线程执行代码，因此主线程可以将主线程上的代码执行完毕。当主线程执行完毕之后，就会执行主队列里面的任务。</code></p>
<h2 id="6、全局队列"><a href="#6、全局队列" class="headerlink" title="6、全局队列"></a>6、全局队列</h2><p>全局队列是系统提供的，无需自己创建，可以直接通过<code>dispatch_get_global_queue(long identifier, unsigned long flags);</code>函数来获取。</p>
<h3 id="6-1-全局队列-异步执行"><a href="#6-1-全局队列-异步执行" class="headerlink" title="6.1 全局队列 异步执行"></a>6.1 全局队列 异步执行</h3><p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 1\. 获取全局队列</span><br><span class="line">dispatch_queue_t q = dispatch_get_global_queue(0, 0);</span><br><span class="line">// 2\. 将任务添加到全局队列, 异步执行</span><br><span class="line">for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    dispatch_async(q, ^&#123;</span><br><span class="line">        NSLog(@&quot;%d %@&quot;, i, [NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>打印输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">2016-02-25 21:29:06.978 test[816:799523] 1 &lt;NSThread: 0x7fd428e15760&gt;&#123;number = 3, name = (null)&#125;  </span><br><span class="line">2016-02-25 21:29:06.978 test[816:799530] 4 &lt;NSThread: 0x7fd428d2fbb0&gt;&#123;number = 6, name = (null)&#125;  </span><br><span class="line">2016-02-25 21:29:06.978 test[816:799522] 0 &lt;NSThread: 0x7fd428f094e0&gt;&#123;number = 2, name = (null)&#125;  </span><br><span class="line">2016-02-25 21:29:06.978 test[816:799529] 3 &lt;NSThread: 0x7fd428c0e1b0&gt;&#123;number = 5, name = (null)&#125;  </span><br><span class="line">2016-02-25 21:29:06.978 test[816:799532] 6 &lt;NSThread: 0x7fd428f06740&gt;&#123;number = 7, name = (null)&#125;  </span><br><span class="line">2016-02-25 21:29:06.978 test[816:799533] 7 &lt;NSThread: 0x7fd428d37be0&gt;&#123;number = 8, name = (null)&#125;  </span><br><span class="line">2016-02-25 21:29:06.978 test[816:799531] 5 &lt;NSThread: 0x7fd428e0c490&gt;&#123;number = 9, name = (null)&#125;  </span><br><span class="line">2016-02-25 21:29:06.978 test[816:799526] 2 &lt;NSThread: 0x7fd428d3e4b0&gt;&#123;number = 4, name = (null)&#125;  </span><br><span class="line">2016-02-25 21:29:06.979 test[816:799534] 8 &lt;NSThread: 0x7fd428d36ab0&gt;&#123;number = 10, name = (null)&#125;  </span><br><span class="line">2016-02-25 21:29:06.979 test[816:799523] 9 &lt;NSThread: 0x7fd428e15760&gt;&#123;number = 3, name = (null)&#125;</span><br></pre></td></tr></table></figure>


<h5 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h5><ol>
<li>全局队列的工作特性跟并发队列一致。 实际上，全局队列就是系统为了方便程序员，专门提供的一种特殊的并发队列。</li>
<li>全局队列和并发队列的区别：</li>
</ol>
<ul>
<li>全局队列没有名称，无论ARC还是MRC都不需要考虑内存释放，日常开发，建议使用全局队列</li>
<li>并发队列有名称，如果在MRC开发中，需要使用<code>dispatch_release</code>来释放相应的对象，<code>dispatch_barrier</code> 必须使用自定义的并发队列，开发第三方框架，建议使用并发队列</li>
</ul>
<h3 id="6-2、函数"><a href="#6-2、函数" class="headerlink" title="6.2、函数"></a>6.2、函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_get_global_queue(long identifier, unsigned long flags);</span><br></pre></td></tr></table></figure>
<p>这个函数中有两个参数:<br>第一个参数: <code>identifier </code><br>iOS7.0，表示的是优先级:<br><code>DISPATCH_QUEUE_PRIORITY_HIGH = 2;</code> 高优先级<br><code>DISPATCH_QUEUE_PRIORITY_DEFAULT = 0;</code> 默认优先级<br><code>DISPATCH_QUEUE_PRIORITY_LOW = -2;</code> 低优先级<br><code>DISPATCH_QUEUE_PRIORITY_BACKGROUND = INT16_MIN; </code>后台优先级<br>iOS8.0开始，推荐使用服务质量(QOS):<br><code>QOS_CLASS_USER_INTERACTIVE = 0x21;</code> 用户交互<br><code>QOS_CLASS_USER_INITIATED = 0x19;</code> 用户期望<br><code>QOS_CLASS_DEFAULT = 0x15;</code> 默认<br><code>QOS_CLASS_UTILITY = 0x11;</code> 实用工具<br><code>QOS_CLASS_BACKGROUND = 0x09;</code> 后台<br><code>QOS_CLASS_UNSPECIFIED = 0x00;</code> 未指定<br>通过对比可知: 第一个参数传入0，可以同时适配iOS7及iOS7以后的版本。<br>服务质量和优先级是一一对应的:  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_QUEUE_PRIORITY_HIGH: QOS_CLASS_USER_INITIATED  </span><br><span class="line">DISPATCH_QUEUE_PRIORITY_DEFAULT: QOS_CLASS_DEFAULT  </span><br><span class="line">DISPATCH_QUEUE_PRIORITY_LOW: QOS_CLASS_UTILITY  </span><br><span class="line">DISPATCH_QUEUE_PRIORITY_BACKGROUND: QOS_CLASS_BACKGROUND</span><br></pre></td></tr></table></figure>

<p>第二个参数: <code>flags  </code><br>为未来保留使用的，始终传入0。<br><code>Reserved for future use.</code></p>
<h2 id="7、GCD总结"><a href="#7、GCD总结" class="headerlink" title="7、GCD总结"></a>7、GCD总结</h2><h3 id="1、开不开线程，由执行任务的函数决定"><a href="#1、开不开线程，由执行任务的函数决定" class="headerlink" title="1、开不开线程，由执行任务的函数决定"></a>1、开不开线程，由执行任务的函数决定</h3><ul>
<li>同步执行不开线程</li>
<li>异步执行开线程</li>
</ul>
<h3 id="2、异步执行任务，开几条线程由队列决定"><a href="#2、异步执行任务，开几条线程由队列决定" class="headerlink" title="2、异步执行任务，开几条线程由队列决定"></a>2、异步执行任务，开几条线程由队列决定</h3><ul>
<li>串行队列，只会开一条线程，因为一条就足够了</li>
<li>并发队列，可以开多条线程，具体开几条由线程池决定</li>
</ul>
<p><code>对主队列而言，不管是同步执行还是异步执行，都不会开线程。</code></p>
<h3 id="最后盗图总结一张"><a href="#最后盗图总结一张" class="headerlink" title="最后盗图总结一张"></a>最后盗图总结一张</h3><p>
        <span class="lazyload-img-span">
        <img   
           data-src="https://upload-images.jianshu.io/upload_images/1442184-2b22e764ef8e39b8.jpg" >
        </sapn>
      </p>
<hr>
<h1 id="六、NSOperation"><a href="#六、NSOperation" class="headerlink" title="六、NSOperation"></a>六、NSOperation</h1><h2 id="1、NSOperation简介"><a href="#1、NSOperation简介" class="headerlink" title="1、NSOperation简介"></a>1、NSOperation简介</h2><h3 id="1-1-NSOperation与GCD的区别："><a href="#1-1-NSOperation与GCD的区别：" class="headerlink" title="1.1 NSOperation与GCD的区别："></a>1.1 NSOperation与GCD的区别：</h3><ul>
<li>OC语言中基于 GCD 的面向对象的封装;</li>
<li>使用起来比 GCD 更加简单;</li>
<li>提供了一些用 GCD 不好实现的功能;</li>
<li>苹果推荐使用，使用 NSOperation 程序员不用关心线程的生命周期</li>
</ul>
<h3 id="1-2NSOperation的特点"><a href="#1-2NSOperation的特点" class="headerlink" title="1.2NSOperation的特点"></a>1.2NSOperation的特点</h3><ul>
<li>NSOperation 是一个抽象类，抽象类不能直接使用,必须使用它的子类</li>
<li>抽象类的用处是定义子类共有的属性和方法</li>
</ul>
<h2 id="2、核心概念"><a href="#2、核心概念" class="headerlink" title="2、核心概念"></a>2、核心概念</h2><ul>
<li><p>将操作添加到队列，异步执行。相对于GCD创建任务，将任务添加到队列。</p>
</li>
<li><p>将NSOperation添加到NSOperationQueue就可以实现多线程编程</p>
</li>
</ul>
<h2 id="3、操作步骤"><a href="#3、操作步骤" class="headerlink" title="3、操作步骤"></a>3、操作步骤</h2><ul>
<li>先将需要执行的操作封装到一个NSOperation对象中</li>
<li>然后将NSOperation对象添加到NSOperationQueue中</li>
<li>系统会自动将NSOperationQueue中的NSOperation取出来</li>
<li>将取出的NSOperation封装的操作放到一条新线程中执行</li>
</ul>
<h2 id="4、NSInvocationOperation"><a href="#4、NSInvocationOperation" class="headerlink" title="4、NSInvocationOperation"></a>4、<code>NSInvocationOperation</code></h2><h3 id="方式一-1"><a href="#方式一-1" class="headerlink" title="方式一"></a>方式一</h3><p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;  </span><br><span class="line">    [super viewDidLoad];  </span><br><span class="line">    //创建操作，然后调用操作的start方法  </span><br><span class="line">    NSInvocationOperation *op = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(demo) object:nil];  </span><br><span class="line">    NSLog(@&quot;%d&quot;,op.isFinished);  </span><br><span class="line">    [op start];  </span><br><span class="line">    NSLog(@&quot;%d&quot;,op.isFinished);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)demo &#123;  </span><br><span class="line">    NSLog(@&quot;hello %@&quot;,[NSThread currentThread]);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>打印输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2016-02-25 22:12:30.054 test[892:834660] 0  </span><br><span class="line">2016-02-25 22:12:30.054 test[892:834660] hello &lt;NSThread: 0x7fad12704f80&gt;&#123;number = 1, name = main&#125;  </span><br><span class="line">2016-02-25 22:12:30.054 test[892:834660] 1</span><br></pre></td></tr></table></figure>


<p>结论：<code>[op start]在主线程中调用的，所以执行的线程也会是在主线程执行！ 重复调用start也只会执行一次，因为NSOperation会有一个属性去记住，是否已经完成了该操作！</code></p>
<h3 id="方式二-1"><a href="#方式二-1" class="headerlink" title="方式二"></a>方式二</h3><p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;  </span><br><span class="line">    [super viewDidLoad];  </span><br><span class="line">    // 创建操作，将操作添加到NSOperationQueue中，然后就会异步的自动执行  </span><br><span class="line">    NSInvocationOperation *op = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(demo) object:nil];  </span><br><span class="line">    //队列  </span><br><span class="line">    NSOperationQueue *queue = [[NSOperationQueue alloc] init];  </span><br><span class="line">    //把操作添加到队列  </span><br><span class="line">    [queue addOperation:op];  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)demo &#123;  </span><br><span class="line">    NSLog(@&quot;hello %@&quot;,[NSThread currentThread]);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>打印</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2016-02-25 22:21:44.999 test[912:842412] hello &lt;NSThread: 0x7fab92610080&gt;&#123;number = 2, name = (null)&#125;</span><br></pre></td></tr></table></figure>

<p><code>将操作添加到NSOperationQueue中，然后就会异步的自动执行</code></p>
<h2 id="5、NSBlockOperation"><a href="#5、NSBlockOperation" class="headerlink" title="5、NSBlockOperation"></a>5、NSBlockOperation</h2><ul>
<li>NSBlockOperation 中使用block的方式让所有代码逻辑在一起，使用起来更加简便。**</li>
</ul>
<h3 id="方式一-2"><a href="#方式一-2" class="headerlink" title="方式一"></a>方式一</h3><p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//创建操作  </span><br><span class="line">NSBlockOperation *op = [NSBlockOperation blockOperationWithBlock:^&#123;  </span><br><span class="line">NSLog(@&quot;hello %@&quot;,[NSThread currentThread]);  </span><br><span class="line">&#125;];  </span><br><span class="line">//更新op的状态，执行main方法，不会开新线程  </span><br><span class="line">[op start];</span><br></pre></td></tr></table></figure>


<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2016-02-25 22:25:30.442 test[923:846208] hello &lt;NSThread: 0x7fd410d055a0&gt;&#123;number = 1, name = main&#125;</span><br></pre></td></tr></table></figure>


<h3 id="方式二-2"><a href="#方式二-2" class="headerlink" title="方式二"></a>方式二</h3><p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 创建队列，创建操作，将操作添加到队列中执行  </span><br><span class="line">NSOperationQueue *queue = [[NSOperationQueue alloc] init];  </span><br><span class="line">NSBlockOperation *op = [NSBlockOperation blockOperationWithBlock:^&#123;  </span><br><span class="line">NSLog(@&quot;hello %@&quot;,[NSThread currentThread]);  </span><br><span class="line">&#125;];  </span><br><span class="line">[queue addOperation:op];</span><br></pre></td></tr></table></figure>


<p>输出  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2016-02-25 22:26:48.064 test[934:848038] hello &lt;NSThread: 0x7fc6bbb24c80&gt;&#123;number = 2, name = (null)&#125;</span><br></pre></td></tr></table></figure>


<h3 id="方式三-1"><a href="#方式三-1" class="headerlink" title="方式三"></a>方式三</h3><p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NSOperationQueue *queue = [[NSOperationQueue alloc] init];</span><br><span class="line"></span><br><span class="line">[queue addOperationWithBlock:^&#123;</span><br><span class="line">    NSLog(@&quot;hello %@&quot;,[NSThread currentThread]);</span><br><span class="line"></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>


<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2016-02-25 22:27:56.445 test[945:850128] hello &lt;NSThread: 0x7f98dbc2cae0&gt;&#123;number = 2, name = (null)&#125;</span><br></pre></td></tr></table></figure>

<p><code>创建队列，添加block形式的操作</code></p>
<hr>
<h1 id="七、案例"><a href="#七、案例" class="headerlink" title="七、案例"></a>七、案例</h1><h2 id="线程之间的通信问题"><a href="#线程之间的通信问题" class="headerlink" title="线程之间的通信问题"></a>线程之间的通信问题</h2><h3 id="技术方案：NSOperation"><a href="#技术方案：NSOperation" class="headerlink" title="技术方案：NSOperation"></a>技术方案：NSOperation</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[self.queue addOperationWithBlock:^&#123;  </span><br><span class="line">    NSLog(@&quot;异步下载图片&quot;);  </span><br><span class="line">    [[NSOperationQueue mainQueue] addOperationWithBlock:^&#123;  </span><br><span class="line">        NSLog(@&quot;回到主线程，更新UI&quot;);  </span><br><span class="line">    &#125;];  </span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>


<h3 id="技术方案：GCD"><a href="#技术方案：GCD" class="headerlink" title="技术方案：GCD"></a>技术方案：GCD</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">    NSLog(@&quot;下载图片---%@&quot;,[NSThread currentThread]);</span><br><span class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        NSLog(@&quot;回到主线程刷新图片的显示 -%@&quot;,[NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2023/03/24/使用Fastlane对iOS项目持续集成（自动打包/"><span></span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2023/03/24/使用Fastlane对iOS项目持续集成（自动打包/" rel="bookmark">
        <time class="entry-date published" datetime="2023-03-24T03:55:10.817Z">
          2023-03-24
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>作为一名iOS app开发者，在我的工作过程中，基本遵循如下的一个流程：<strong><strong>分析需求、UI设计——&gt;设计功能架构——&gt;着手开发——&gt;打测试包——&gt;修复bug、优化功能</strong></strong>。</p>
<p>在所有这些工作中，项目打测试包对于一个开发人员来说，可以说是一项无脑又浪费时间的工作，很荣幸的是，我在公司负责iOS项目的打包。</p>
<p>那么来看看打包的时间都浪费在哪了。来看下打包的流程：Archive项目——&gt;勾选一堆选项及下一步，打包用途、app瘦身、证书——&gt;导出ipa包——&gt;打开蒲公英——&gt;上传ipa包——&gt;填写项目描述、安装密码——&gt;发布测试包。如此这般下来，真的是被恶心吐了，手动的操作是一方面，另一方面，在进行编译项目、导出ipa、上传ipa这些操作时，则需要等待很长时间，只有等待上一步耗时操作完成，才能进行下一步，无疑很浪费时间。</p>
<p>那么当然会有一种办法，能为我们解决这个问题，因为懒才是科技进步的第一生产力。</p>
</blockquote>
<h2 id="Fastlane"><a href="#Fastlane" class="headerlink" title="Fastlane"></a><a target="_blank" rel="noopener" href="https://fastlane.tools/">Fastlane</a></h2><p>这里就要引入一个概念了，叫持续集成，引用下百度百科的介绍：</p>
<blockquote>
<p>持续集成是一种软件开发实践，即团队开发成员经常集成他们的工作，通常每个成员每天至少集成一次，也就意味着每天可能会发生多次集成。每次集成都通过自动化的构建（包括编译，发布，自动化测试）来验证，从而尽早地发现集成错误。</p>
</blockquote>
<p>而今天文章的主角就是Fastlane，一套ruby编写的持续集成工具集。通过Fastlane可以实现自动打包、发布、截取app图片等工作，而Fastlane可以执行通过ruby代码或者Fastlane提供的一些工具编写的脚本来实现这些工作。以下皆以打包发布到<a target="_blank" rel="noopener" href="https://www.pgyer.com/doc/view/fastlane">蒲公英</a>为例，因为蒲公英为开发者提供了Fastlane的蒲公英插件，允许开发者通过Fastlane上传ipa包到蒲公英，fir好像也提供了Fastlane的插件，具体没去了解，如果有使用fir的，可以在回复中补充。</p>
<p>
        <span class="lazyload-img-span">
        <img   
           data-src="https://upload-images.jianshu.io/upload_images/1682338-2be75e344eedd459.png" >
        </sapn>
      </p>
<h2 id="集成流程及使用方法"><a href="#集成流程及使用方法" class="headerlink" title="集成流程及使用方法"></a>集成流程及使用方法</h2><h3 id="1、ruby"><a href="#1、ruby" class="headerlink" title="1、ruby"></a>1、ruby</h3><p>因为Fastlane是ruby编写的，所以我们首先保证电脑的ruby环境有正确安装，打开终端，输入如下命令来查看ruby版本。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby -v</span><br></pre></td></tr></table></figure>
<p>
        <span class="lazyload-img-span">
        <img   
           data-src="https://upload-images.jianshu.io/upload_images/1682338-7ed82e907d636f7f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" >
        </sapn>
      </p>
<p>这里保证ruby版本在2.0以上就好了。如果低于2.0，就需要升级ruby了，这里不提了，百度谷歌都有教程。</p>
<h3 id="2、安装Fastlane"><a href="#2、安装Fastlane" class="headerlink" title="2、安装Fastlane"></a>2、安装Fastlane</h3><p>首先安装Xcode命令行工具，因为编译、打包等操作，虽然是Fastlane帮我们做的，但本质上还是通过Xcode中的构建工具来完成的。在终端中运行如下命令，则会安装Xcode命令行工具：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcode-select --install</span><br></pre></td></tr></table></figure>
<p>
        <span class="lazyload-img-span">
        <img   
           data-src="https://upload-images.jianshu.io/upload_images/1868441-6a476ef5d297906d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" >
        </sapn>
      </p>
<p>这里代表Xcode命令行工具已安装</p>
<p>
        <span class="lazyload-img-span">
        <img   
           data-src="https://upload-images.jianshu.io/upload_images/1868441-d54f5fef495b6da0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" >
        </sapn>
      <br>这里需要选中Xcode命令行工具</p>
<p>
        <span class="lazyload-img-span">
        <img   
           data-src="https://upload-images.jianshu.io/upload_images/1682338-241e361b6753030c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" >
        </sapn>
      </p>
<p>然后安装Fastlane：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gem install fastlane --verbose</span><br></pre></td></tr></table></figure>


<p>如果发现最后报了这样的错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ERROR:  While executing gem ... (TypeError)</span><br><span class="line"></span><br><span class="line">    no implicit conversion of nil into String</span><br></pre></td></tr></table></figure>


<p>则更新gem版本，然后再次安装Fastlane：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gem update --system</span><br></pre></td></tr></table></figure>


<p>如果报错：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ERROR:  While executing gem ... (Gem::FilePermissionError)</span><br><span class="line"></span><br><span class="line">    You don&#x27;t have write permissions for the /usr/bin directory.</span><br></pre></td></tr></table></figure>


<p>则尝试使用如下命令进行安装：</p>
<p>sudo gem install -n &#x2F;usr&#x2F;local&#x2F;bin fastlane</p>
<p>如果还安装失败。。。去官网看看别的安装方法吧：<a target="_blank" rel="noopener" href="https://docs.fastlane.tools/getting-started/ios/setup/">Getting started with fastlane for iOS</a></p>
<p>为了检查Fastlane是否成功安装，可以通过下面的命令来查看Fastlane版本号：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastlane --version</span><br></pre></td></tr></table></figure>


<h3 id="3、为项目初始化Fastlane"><a href="#3、为项目初始化Fastlane" class="headerlink" title="3、为项目初始化Fastlane"></a>3、为项目初始化Fastlane</h3><p>如果Fastlane正确安装了，就可以为我们的项目初始化Fastlane了，首先通过终端，CD到项目目录，也就是项目的.xcodeproj文件所在位置。然后执行Fastlane初始化命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastlane init</span><br></pre></td></tr></table></figure>


<p>这里如果一直卡在bundle update，那应该就是被墙了，这时候来到项目目录下，找到Gemfile，打开Gemfile将里面的内容修改为如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#source &quot;https://rubygems.org&quot;</span><br><span class="line"></span><br><span class="line">source &quot;https://gems.ruby-china.com/&quot;</span><br><span class="line"></span><br><span class="line">gem &quot;fastlane&quot;</span><br></pre></td></tr></table></figure>


<p>重开终端，运行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ bundle update</span><br></pre></td></tr></table></figure>
<p>就好了。</p>
<p>初始化结束后，会提示选择Fastlane的用途，一共是四个选项，我选了最后一个，自定义，然后打开项目目录，会发现多了一个fastlane文件夹：</p>
<p>
        <span class="lazyload-img-span">
        <img   
           data-src="https://upload-images.jianshu.io/upload_images/1682338-ef9ecba794bd2664.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" >
        </sapn>
      </p>
<p>然后安装蒲公英插件，安装后有个y&#x2F;n的选择，选择y：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastlane add_plugin pgyer</span><br></pre></td></tr></table></figure>
<p>升级插件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bundle exec fastlane update_plugins</span><br></pre></td></tr></table></figure>
<p>打开文件夹中的Fastfile，里面则是执行自动化打包任务的代码，这里我是用sublime打开的，在sublime的菜单中，找到View——&gt;Syntax中选择ruby，即可高亮代码：</p>
<p>
        <span class="lazyload-img-span">
        <img   
           data-src="https://upload-images.jianshu.io/upload_images/1682338-4b01919d5ec865d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" >
        </sapn>
      </p>
<h3 id="4、创建一个lane"><a href="#4、创建一个lane" class="headerlink" title="4、创建一个lane"></a>4、创建一个lane</h3><p>Fastlane以lane为单位，去执行一个自动化任务，Fastfile中的代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">default_platform(:ios)</span><br><span class="line"></span><br><span class="line">platform :ios do</span><br><span class="line"></span><br><span class="line">  desc &quot;Description of what the lane does&quot;</span><br><span class="line"></span><br><span class="line">  lane :custom_lane do</span><br><span class="line"></span><br><span class="line">    # add actions here: https://docs.fastlane.tools/actions</span><br><span class="line"></span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure>


<p><strong>lane：custom_lane</strong>，代表了一个叫<strong>custom_lane</strong>的任务，后面的do，则表示需要执行的操作。这里就不讲怎么写代码了（因为我也不会ruby啊！现用现找就好了），我把我项目中的Fastfile贴上来，讲解下Fastfile做了哪些事（见代码中的注释）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">default_platform(:ios)</span><br><span class="line"></span><br><span class="line">platform :ios do</span><br><span class="line">  desc &quot;Description of what the lane does&quot;</span><br><span class="line">  lane :dev do      #给lane命名</span><br><span class="line"></span><br><span class="line">#从蒲公英平台拿到的api_key和user_key，下面我会讲怎么拿到这两个key，存在下面两个变量中</span><br><span class="line">api_key = &quot;***********************&quot;</span><br><span class="line">user_key = &quot;***********************&quot;</span><br><span class="line"></span><br><span class="line">#输入蒲公英上传ipa包后输入的版本描述信息</span><br><span class="line">puts &quot;请输入版本描述：&quot;</span><br><span class="line">desc = STDIN.gets</span><br><span class="line"></span><br><span class="line">puts &quot;开始打包&quot;</span><br><span class="line"># 开始打包</span><br><span class="line">gym(</span><br><span class="line">#指定scheme的名字</span><br><span class="line">scheme: &quot;mango&quot;,</span><br><span class="line">#输出的ipa名称</span><br><span class="line">output_name:&quot;mango&quot;,</span><br><span class="line"># 是否清空以前的编译信息 true：是</span><br><span class="line">clean:true,</span><br><span class="line"># 指定打包方式，Release 或者 Debug</span><br><span class="line">configuration:&quot;Release&quot;,</span><br><span class="line"># 指定打包所使用的输出方式，目前支持app-store, package, ad-hoc, enterprise, development</span><br><span class="line">export_method:&quot;ad-hoc&quot;,</span><br><span class="line"># 指定输出文件夹，这里会保存我们最后生成的ipa文件，也就是存到了我们上面提到的fastlane文件夹中的build文件夹中</span><br><span class="line">output_directory:&quot;./build&quot;,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">puts &quot;开始上传到蒲公英&quot;</span><br><span class="line">#开始上传ipa到蒲公英，这里用的是蒲公英提供的插件</span><br><span class="line">#update_description代表更新信息，password代表安装密码</span><br><span class="line">pgyer(update_description: &quot;#&#123;desc&#125;&quot;, api_key: &quot;#&#123;api_key&#125;&quot;, user_key: &quot;#&#123;user_key&#125;&quot;, password: &quot;kltb&quot;, install_type: &quot;2&quot;)</span><br><span class="line"></span><br><span class="line">#在上传完ipa后，打开ipa的存放文件夹，起到提示上传完成的作用</span><br><span class="line">system &quot;open ../build&quot;</span><br><span class="line"></span><br><span class="line">end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>至于蒲公英的api_key和user_key，可以在蒲公英官网的我的应用——&gt;之前发布的应用——&gt;API中找到：</p>
<p>
        <span class="lazyload-img-span">
        <img   
           data-src="https://upload-images.jianshu.io/upload_images/1682338-b419e5eb2852f3ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" >
        </sapn>
      </p>
<h3 id="4、执行脚本"><a href="#4、执行脚本" class="headerlink" title="4、执行脚本"></a>4、执行脚本</h3><p>cd到项目目录，输入如下命令来执行我们自己定义的lane，格式如下fastlane+脚本第一行中的platform名+脚本第二行中的lane名：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastlane ios dev</span><br></pre></td></tr></table></figure>


      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>




<nav class="pagination">
  
  
</nav>
    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2023 John Doe
    
  </p>
</footer>
    
    
  </div>
</div>
</body>
</html>