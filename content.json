{"pages":[],"posts":[{"title":"","text":"说一下KVC和KVO本篇采用简单的例子，来介绍 iOS 中的 KVC 和 KVO 的用法和实现原理。 一、KVC1. KVC是什么KVC 即 Key-Value Coding，翻译成键值编码。它是一种不通过存取方法，而通过属性名称字符串间接访问属性的机制。 2. KVC的用法KVC 常用到的方法有下面几个： 12345- (id)valueForKey:(NSString *)key; - (void)setValue:(nullable id)value forKey:(NSString *)key; - (nullable id)valueForKeyPath:(NSString *)keyPath; - (void)setValue:(nullable id)value forKeyPath:(NSString *)keyPath; 前面的两个方法，以字符串的形式传入对象属性即可调用。私有属性也可以调用。如下代码所示： 1234567891011121314151617181920212223242526272829// 先声明一个对象ObjectA，同时具备私有属性和公有属性 // ObjectA.h @interface ObjectA : NSObject @property (nonatomic, strong) NSString *publicPropertyString; @end // ObjectA.m @interface ObjectA () @property (nonatomic, assign) NSInteger privatePropertyInteger; @end @implementation ObjectA - (instancetype)init { self = [super init]; if (self) { self.publicPropertyString = @&quot;publicPropertyString&quot;; self.privatePropertyInteger = 2000; } return self; } @end 1234567891011121314// 尝试调用 ObjectA *objectA = [[ObjectA alloc] init]; // 以下输出：publicPropertyString NSLog(@&quot;%@&quot;, [objectA valueForKey:@&quot;publicPropertyString&quot;]); // 以下输出：2000 NSLog(@&quot;%@&quot;, [objectA valueForKey:@&quot;privatePropertyInteger&quot;]); // 将999赋值给privatePropertyInteger [objectA setValue:@(999) forKey:@&quot;privatePropertyInteger&quot;]; // 以下输出：999 NSLog(@&quot;%@&quot;, [objectA valueForKey:@&quot;privatePropertyInteger&quot;]); 后面两个方法支持传入用 . 连接的多层级属性，比如 school.schoolmaster.name 。同样支持私有属性。如下代码所示： 123456789101112131415161718192021// 再声明一个对象ObjectB，具备私有属性ObjectA// ObjectB.m@interface ObjectB ()@property (nonatomic, strong) ObjectA *objectA;@end@implementation ObjectB- (instancetype)init { self = [super init]; if (self) { self.objectA = [[ObjectA alloc] init]; } return self;}@end 12345678// 尝试调用 ObjectB *objectB = [[ObjectB alloc] init]; // 将999赋值给objectA的属性privatePropertyInteger [objectB setValue:@(999) forKeyPath:@&quot;objectA.privatePropertyInteger&quot;]; // 以下输出：999 NSLog(@&quot;%@&quot;, [objectB valueForKeyPath:@&quot;objectA.privatePropertyInteger&quot;]); 需要注意： 当 value 的值为基本类型时，应该封装为 NSNumber 或 NSValue 。 KVC不会自动调用键值验证方法。当字符串中的属性值不存在时，会直接抛出异常。 可以先在类中重写 -validateValue: forKey: error: ，制定检查规则，然后手动调用该方法来验证。 KVC的一个重要应用是字典转模型。 3. KVC的原理为了设置或者获取对象属性，KVC按顺序使用如下技术： 获取对象属性时，检查是否存在 -&lt;key&gt; 、 -is&lt;key&gt;（只针对布尔值有效）或者 -get&lt;key&gt; 的访问器方法，如果找到，就用这些方法来返回属性值；设置对象属性时，检查是否存在名为 -set&lt;key&gt;: 的方法，并使用它来设置属性值。对于 -get&lt;key&gt; 和 -set&lt;key&gt;: 方法，将大写Key字符串的第一个字母，并与Cocoa的方法命名保持一致。 如果上述方法找不到，则检查名为 -_&lt;key&gt; 、 -_is&lt;key&gt;（只针对布尔值有效）、 -_get&lt;key&gt; 和 -_set&lt;key&gt;: 方法。 如果没有找到访问器方法，则尝试直接访问实例变量。实例变量可以是名为： &lt;key&gt; 或 _&lt;key&gt; 。 如果仍未找到，则调用 valueForUndefinedKey: 和 setValue:forUndefinedKey: 方法。这些方法的默认实现都是抛出异常，可以根据需要重写它们。 可以看到，KVC会优先使用访问器方法来访问对象属性。 二、KVO1. KVO是什么KVO 即 Key-Value Observing，翻译成键值观察。它是一种观察者模式的衍生。其基本思想是，对目标对象的某属性添加观察，当该属性发生变化时，通过触发观察者对象实现的KVO接口方法，来自动的通知观察者。 2. KVO的用法KVO的使用主要分为三步： 第一步，将目标对象添加为观察者。（注意这里用到了KVC，即通过字符串的方式去访问属性值。） 1234- (void)addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(nullable void *)context; 第二步，实现接收通知的接口方法。 1234- (void)observeValueForKeyPath:(nullable NSString *)keyPath ofObject:(nullable id)object change:(nullable NSDictionary&lt;NSKeyValueChangeKey, id&gt; *)change context:(nullable void *)context; 第三步，移除观察者。 12- (void)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath; 在第一步中，NSKeyValueObservingOptions类型有四个取值，可以通过 | 来连接多个取值。分别为： NSKeyValueObservingOptionNew，在属性值变化的时候回调，可以在change中取到变化后的值。 NSKeyValueObservingOptionOld，在属性值变化的时候回调，可以在change中取到变化前的值。 NSKeyValueObservingOptionInitial，在属性值初始化或者变化的时候回调，拿不到变化前后的值。 NSKeyValueObservingOptionPrior，在属性值变化前和变化后各回调一次，拿不到变化前后的值。 举一个例子： 123456789101112131415161718192021222324252627282930313233343536373839404142@interface ObjectB () @property (nonatomic, strong) ObjectA *objectA; @end @implementation ObjectB - (instancetype)init { self = [super init]; if (self) { self.objectA = [[ObjectA alloc] init]; // 第一步，将目标对象添加为观察者 [_objectA addObserver:self forKeyPath:@&quot;privatePropertyInteger&quot; options:NSKeyValueObservingOptionNew context:nil]; [_objectA setValue:@(999) forKey:@&quot;privatePropertyInteger&quot;; } return self; } // 第二步，实现接收通知的接口方法 - (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context { // 这里最好判断一下object的类型和keyPath的值，不符合则交给父类处理 if ([object isKindOfClass:[ObjectA class]] &amp;&amp; [keyPath isEqualToString:@&quot;privatePropertyInteger&quot;]) { NSLog(@&quot;%@&quot;, change); // 这里可以读取到 new = 999 } else { [super observeValueForKeyPath:keyPath ofObject:object change:change context:context\\]; } } // 第三步，移除观察者。 - (void) dealloc { [_objectA removeObserver:self forKeyPath:@&quot;privatePropertyInteger&quot;\\]; } @end KVO可以在MVC模式中得到很好的应用。因为当Model发生变化时，通过KVO可以很方便地通知到Controller，从而通过Controller来改变View的展示。所以说KVO是解决Model和View同步的好办法。 3. KVO的原理KVO的实现依赖于Runtime的强大动态能力。 当某个类的对象第一次被观察时，系统就会在运行期动态地创建该类的一个派生类，在这个派生类中重写这个类中任何被观察属性的 setter 方法。 即当一个类型为 ObjectA 的对象，被添加了观察后，系统会生成一个 NSKVONotifying_ObjectA 类，并将对象的isa指针指向新的类，也就是说这个对象的类型发生了变化。这个类相比较于ObjectA，会重写以下几个方法。 1. 重写setter在 setter 中，会添加以下两个方法的调用。 12- (void)willChangeValueForKey:(NSString *)key; - (void)didChangeValueForKey:(NSString *)key; 然后在 didChangeValueForKey: 中，去调用： 1234- (void)observeValueForKeyPath:(nullable NSString *)keyPath ofObject:(nullable id)object change:(nullable NSDictionary&lt;NSKeyValueChangeKey, id&gt; *)change context:(nullable void *)context; 于是实现了属性值修改的通知。因为 KVO 的原理是修改 setter 方法，因此使用 KVO 必须调用 setter 。若直接访问属性对象则没有效果。 2. 重写class当修改了isa指向后，class的返回值不会变，但isa的值则发生改变。 1234567// 添加Observer之后 // 输出ObjectA NSLog(@&quot;%@&quot;, [_objectA class]); // 输出NSKVONotifying_ObjectA（object_getClass方法返回isa指向） NSLog(@&quot;%@&quot;, object_getClass(_objectA)); 3. 重写dealloc系统重写 dealloc 方法来释放资源。 4. 重写_isKVOA这个私有方法估计是用来标示该类是一个 KVO 机制声称的类。 #参考 KVC和KVO的使用及原理KVC/KVO原理详解及编程指南iOS里的KVO模式","link":"/2023/03/24/KVC%20KVO/"},{"title":"","text":"前言 作为一名iOS app开发者，在我的工作过程中，基本遵循如下的一个流程：分析需求、UI设计——&gt;设计功能架构——&gt;着手开发——&gt;打测试包——&gt;修复bug、优化功能。 在所有这些工作中，项目打测试包对于一个开发人员来说，可以说是一项无脑又浪费时间的工作，很荣幸的是，我在公司负责iOS项目的打包。 那么来看看打包的时间都浪费在哪了。来看下打包的流程：Archive项目——&gt;勾选一堆选项及下一步，打包用途、app瘦身、证书——&gt;导出ipa包——&gt;打开蒲公英——&gt;上传ipa包——&gt;填写项目描述、安装密码——&gt;发布测试包。如此这般下来，真的是被恶心吐了，手动的操作是一方面，另一方面，在进行编译项目、导出ipa、上传ipa这些操作时，则需要等待很长时间，只有等待上一步耗时操作完成，才能进行下一步，无疑很浪费时间。 那么当然会有一种办法，能为我们解决这个问题，因为懒才是科技进步的第一生产力。 Fastlane这里就要引入一个概念了，叫持续集成，引用下百度百科的介绍： 持续集成是一种软件开发实践，即团队开发成员经常集成他们的工作，通常每个成员每天至少集成一次，也就意味着每天可能会发生多次集成。每次集成都通过自动化的构建（包括编译，发布，自动化测试）来验证，从而尽早地发现集成错误。 而今天文章的主角就是Fastlane，一套ruby编写的持续集成工具集。通过Fastlane可以实现自动打包、发布、截取app图片等工作，而Fastlane可以执行通过ruby代码或者Fastlane提供的一些工具编写的脚本来实现这些工作。以下皆以打包发布到蒲公英为例，因为蒲公英为开发者提供了Fastlane的蒲公英插件，允许开发者通过Fastlane上传ipa包到蒲公英，fir好像也提供了Fastlane的插件，具体没去了解，如果有使用fir的，可以在回复中补充。 集成流程及使用方法1、ruby因为Fastlane是ruby编写的，所以我们首先保证电脑的ruby环境有正确安装，打开终端，输入如下命令来查看ruby版本。 1ruby -v 这里保证ruby版本在2.0以上就好了。如果低于2.0，就需要升级ruby了，这里不提了，百度谷歌都有教程。 2、安装Fastlane首先安装Xcode命令行工具，因为编译、打包等操作，虽然是Fastlane帮我们做的，但本质上还是通过Xcode中的构建工具来完成的。在终端中运行如下命令，则会安装Xcode命令行工具： 1xcode-select --install 这里代表Xcode命令行工具已安装 这里需要选中Xcode命令行工具 然后安装Fastlane： 1sudo gem install fastlane --verbose 如果发现最后报了这样的错误： 123ERROR: While executing gem ... (TypeError) no implicit conversion of nil into String 则更新gem版本，然后再次安装Fastlane： 1sudo gem update --system 如果报错： 123ERROR: While executing gem ... (Gem::FilePermissionError) You don't have write permissions for the /usr/bin directory. 则尝试使用如下命令进行安装： sudo gem install -n /usr/local/bin fastlane 如果还安装失败。。。去官网看看别的安装方法吧：Getting started with fastlane for iOS 为了检查Fastlane是否成功安装，可以通过下面的命令来查看Fastlane版本号： 1fastlane --version 3、为项目初始化Fastlane如果Fastlane正确安装了，就可以为我们的项目初始化Fastlane了，首先通过终端，CD到项目目录，也就是项目的.xcodeproj文件所在位置。然后执行Fastlane初始化命令： 1fastlane init 这里如果一直卡在bundle update，那应该就是被墙了，这时候来到项目目录下，找到Gemfile，打开Gemfile将里面的内容修改为如下： 12345#source &quot;https://rubygems.org&quot;source &quot;https://gems.ruby-china.com/&quot;gem &quot;fastlane&quot; 重开终端，运行 1$ bundle update 就好了。 初始化结束后，会提示选择Fastlane的用途，一共是四个选项，我选了最后一个，自定义，然后打开项目目录，会发现多了一个fastlane文件夹： 然后安装蒲公英插件，安装后有个y/n的选择，选择y： 1fastlane add_plugin pgyer 升级插件 1bundle exec fastlane update_plugins 打开文件夹中的Fastfile，里面则是执行自动化打包任务的代码，这里我是用sublime打开的，在sublime的菜单中，找到View——&gt;Syntax中选择ruby，即可高亮代码： 4、创建一个laneFastlane以lane为单位，去执行一个自动化任务，Fastfile中的代码如下： 12345678910111213default_platform(:ios)platform :ios do desc &quot;Description of what the lane does&quot; lane :custom_lane do # add actions here: https://docs.fastlane.tools/actions endend lane：custom_lane，代表了一个叫custom_lane的任务，后面的do，则表示需要执行的操作。这里就不讲怎么写代码了（因为我也不会ruby啊！现用现找就好了），我把我项目中的Fastfile贴上来，讲解下Fastfile做了哪些事（见代码中的注释）： 1234567891011121314151617181920212223242526272829303132333435363738394041default_platform(:ios)platform :ios do desc &quot;Description of what the lane does&quot; lane :dev do #给lane命名#从蒲公英平台拿到的api_key和user_key，下面我会讲怎么拿到这两个key，存在下面两个变量中api_key = &quot;***********************&quot;user_key = &quot;***********************&quot;#输入蒲公英上传ipa包后输入的版本描述信息puts &quot;请输入版本描述：&quot;desc = STDIN.getsputs &quot;开始打包&quot;# 开始打包gym(#指定scheme的名字scheme: &quot;mango&quot;,#输出的ipa名称output_name:&quot;mango&quot;,# 是否清空以前的编译信息 true：是clean:true,# 指定打包方式，Release 或者 Debugconfiguration:&quot;Release&quot;,# 指定打包所使用的输出方式，目前支持app-store, package, ad-hoc, enterprise, developmentexport_method:&quot;ad-hoc&quot;,# 指定输出文件夹，这里会保存我们最后生成的ipa文件，也就是存到了我们上面提到的fastlane文件夹中的build文件夹中output_directory:&quot;./build&quot;,)puts &quot;开始上传到蒲公英&quot;#开始上传ipa到蒲公英，这里用的是蒲公英提供的插件#update_description代表更新信息，password代表安装密码pgyer(update_description: &quot;#{desc}&quot;, api_key: &quot;#{api_key}&quot;, user_key: &quot;#{user_key}&quot;, password: &quot;kltb&quot;, install_type: &quot;2&quot;)#在上传完ipa后，打开ipa的存放文件夹，起到提示上传完成的作用system &quot;open ../build&quot;endend 至于蒲公英的api_key和user_key，可以在蒲公英官网的我的应用——&gt;之前发布的应用——&gt;API中找到： 4、执行脚本cd到项目目录，输入如下命令来执行我们自己定义的lane，格式如下fastlane+脚本第一行中的platform名+脚本第二行中的lane名： 1fastlane ios dev","link":"/2023/03/24/%E4%BD%BF%E7%94%A8Fastlane%E5%AF%B9iOS%E9%A1%B9%E7%9B%AE%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%EF%BC%88%E8%87%AA%E5%8A%A8%E6%89%93%E5%8C%85/"},{"title":"","text":"一、多线程简介1、多线程的由来一个进程（进程）在执行一个线程（线程中有很多函数或方法（后面简称Function））的时候，其中有一个Function执行的时候需要消耗一些时间，但是这个线程又必须同时执行这个Function之后的Function，问题来了，一个线程中的任何一个Function都必须等待其执行完成后才能执行后面的Function，如果要同时执行两个或者多个Function，那么，就必须多开一个或者多个线程，这就是多线程的产生。我想多线程最开始的诞生就是由这而来吧！ 2、耗时操作的模拟试验2.1 循环测试代码 123456789int main(int argc, const char * argv[]) { @autoreleasepool { NSLog(@&quot;bengin&quot;); for (int i = 0; i &lt; 10000000; i++) { } NSLog(@&quot;end&quot;); } return 0; } 控制台 1232016-02-16 13:51:54.140 Test[1670:603696] bengin 2016-02-16 13:51:54.160 Test[1670:603696] end Program ended with exit code: 0 结论一：循环一亿次耗时0.02秒，计算机的运行速度是非常快的 2.2 操作栈区代码 12345678910int main(int argc, const char * argv[]) { @autoreleasepool { NSLog(@&quot;bengin&quot;); for (int i = 0; i &lt; 10000000; i++) { int n = 1; } NSLog(@&quot;end&quot;); } return 0; } 控制台 1232016-02-16 13:57:37.589 Test[1734:631377] bengin 2016-02-16 13:57:37.612 Test[1734:631377] end Program ended with exit code: 0 结论二：对栈区操作一亿次，耗时0.023秒 2.3 操作常量区代码： 12345678910int main(int argc, const char * argv[]) { @autoreleasepool { NSLog(@&quot;bengin&quot;); for (int i = 0; i &lt; 10000000; i++) { NSString *str = @&quot;hellow&quot;; } NSLog(@&quot;end&quot;); } return 0;} 控制台 1232016-02-16 14:03:59.003 Test[1763:659287] bengin 2016-02-16 14:03:59.113 Test[1763:659287] end Program ended with exit code: 0 结论三：对常量区操作一亿次，耗时0.11秒 2.4 操作堆区代码 1234567891011int main(int argc, const char * argv[]) { @autoreleasepool { NSLog(@&quot;bengin&quot;); for (int i = 0; i &lt; 10000000; i++) { NSString *str = [NSString stringWithFormat:@&quot;%d&quot;,i]; } NSLog(@&quot;end&quot;); } return 0;} 控制台 1232016-02-16 14:09:03.673 Test[1786:673719] bengin 2016-02-16 14:09:10.705 Test[1786:673719] end Program ended with exit code: 0 结论四：对堆区操作一亿次耗时7秒多一些，较慢！ 2.5 I/O操作代码 12345678910int main(int argc, const char * argv[]) { @autoreleasepool { NSLog(@&quot;bengin&quot;); for (int i = 0; i &lt; 10000000; i++) { NSLog(@&quot;%d&quot;,i); } NSLog(@&quot;end&quot;); } return 0;} 控制台输出！正在跑中，一亿次！！！先看截图CPU 再看内存 好吧，还在跑，现在已经达到10分钟了，怕心疼本本炸掉！stop。。。结论五：I/O操作非常慢，一亿次10分钟也没能跑完！ 最终结论：通过以上结论一、二、三、四、五得出一个结论，各个区的执行效率：栈区&gt;常量区&gt;堆区&gt;I/O操作。同时也说明了一个问题，执行不同的方法会产什么耗时操作。这是，为了解决耗时操作问题，多线程闪亮诞生！ 3、进程和线程先说说进程和线程吧！ 3.1 进程3.1.1 进程的概念：系统中正在运行的应用程序。 3.1.2 进程的特点：每个进程都运行在其专用且受保护的内存空间，不同的进程之间相互独立，互不干扰。 3.2 线程3.2.1 线程的概念：线程是进程的执行任务的基本单元，一个进程的所有任务都是在线程中执行的。（每一个进程至少要有一条线程）。 3.2.2 线程的特点：线程在执行任务的时候是按顺序执行的。如果要让一条线程执行多个任务，那么只能一个一个地并且按顺序执行这些任务。也就是说，在同一时间，一条线程只能执行一个任务。 我们可以通过Mac中的活动监视器查看进程和线程，下图！ 4、多线程的概念及原理4.1 多线程概念：1个进程可以开启多条线程，多条线程可以同时执行不同的任务。 4.2 多线程原理： 前提是在单核CPU的情况下，同一时间，CPU只能处理一条线程，也就是说只有一条线程在执行任务。多线程同时执行，那是不可能的！但是是CPU快速地在多条线程之间进行调度和切换执行任务。如果CPU调度线程的速度足够快，就会造成多条线程同时执行任务的”假象”，这种假象，就被美誉为：多线程! 5、多线程的优缺点和一个Tip5.1 多线程的优点 可以适当提高程序的执行效率 也可以适当提高资源的利用率(CPU、内存利用率) 5.2 多线程的缺点 开启一条线程需要占用一定的内存空间（默认情况下，每一条线程都占用512KB），如果开启大量的线程，会占用大量的内存空间，从而降低程序的性能。 线程越多，CPU在调度和切换线程上的开销就会越大。 线程数越多，程序的设计会越复杂。 5.3 Tip 开启新的线程就会消耗资源，但是却可以提高用户体验。在保证良好的用户体验的前提下，可以适当地开线程，一般开3-6条。 开启一条新的线程，默认情况下，一条线程都是占用512KB，但是官方的文档里面给出的说明却不是，为了得出真相，下面做个小小的测试！ 代码 12345678910111213141516171819int main(int argc, const char * argv[]) { @autoreleasepool { /** 操作主线程 */ NSLog(@&quot;主线程默认 %tu&quot;, [NSThread currentThread].stackSize / 1024); // 设置主线程的stackSize [NSThread currentThread].stackSize = 1024 * 1024; NSLog(@&quot;主线程修改 %tu&quot;, [NSThread currentThread].stackSize / 1024); /** 操作子线程 */ NSThread *thread = [[NSThread alloc] init]; NSLog(@&quot;thread默认 %tu&quot;, thread.stackSize / 1024); // 设置子线程的stackSize thread.stackSize = 8 * 1024; NSLog(@&quot;thread修改 %tu&quot;, thread.stackSize / 1024); [thread start]; } return 0; } 控制台 12342016-02-17 08:36:02.652 Test[609:110129] 主线程默认 512 2016-02-17 08:36:02.654 Test[609:110129] 主线程修改 1024 2016-02-17 08:36:02.654 Test[609:110129] thread默认 512 2016-02-17 08:36:02.654 Test[609:110129] thread修改 8 证明了，不管什么线程，默认都是512，最小为8.可能是官方文档没有及时更新吧！ 6、主线程6.1 主线程的概念：一个应用程序在启动运行后，系统会自动开启1条线程，这条称为”主线程”。 6.2 主线程的作用：主线程的作用主要用于处理UI界面刷新和UI时间！ 6.3 结论： 主线程上不能执行耗时操作，这样会造成界面卡顿，给用户一种不好的体验。 7、技术方案 二、Pthread1、函数1pthread_create(pthread_t *restrict, const pthread_attr_t *restrict, void _(_)(void *), void *restrict) 2、参数和返回值 pthread_t *restrict 线程编号的地址 const pthread_attr_t *restrict 线程的属性 void *(*)(void *) 线程要执行的函数 int * 指向int类型的指针 void * 指向任何类型的指针 有点类似OC中的id void *restrict 要执行的函数的参数 返回值int类型 0是成功 非0 是失败 3、使用代码 1234567891011121314151617181920212223242526272829# import &lt;Foundation/Foundation.h&gt;# import &lt;pthread/pthread.h&gt;void *demo(void *param) { NSString *name = (__bridge NSString *)(param); NSLog(@&quot;hello %@ %@&quot;,name,[NSThread currentThread]); return NULL; }int main(int argc, const char * argv[]) { @autoreleasepool { //创建子线程 pthread_t pthread; //线程编号 NSString *test = @&quot;test&quot;; int result = pthread_create(&amp;pthread, NULL, demo, (__bridge void *)(test)); NSLog(@&quot;Began %@&quot;,[NSThread currentThread]); if (result == 0) { NSLog(@&quot;成功&quot;); }else { NSLog(@&quot;失败&quot;); } } return 0; } 控制台 1232016-02-16 22:00:57.401 Test[888:42585] Began &lt;NSThread: 0x100502d70&gt;{number = 1, name = main} 2016-02-16 22:00:57.403 Test[888:42615] hello test &lt;NSThread: 0x100102a30&gt;{number = 2, name = (null)} 2016-02-16 22:00:57.403 Test[888:42585] 成功 __bridge 桥接，把OC中的对象，传递给c语言的函数，使用__bridge 三、NSThread1、创建一个新的线程 方式一 1NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(demo) object:nil]; 方式二 1[NSThread detachNewThreadSelector:@selector(demo) toTarget:self withObject:nil]; 方式三 1[self performSelectorInBackground:@selector(demo) withObject:nil]; 2、线程的状态线程状态分为五种 创建 New 就绪 Runnable 运行 Running (void)start; 阻塞（暂停） Blocked (void)sleepUntilDate:(NSDate *)date; (void)sleepForTimeInterval:(NSTimeInterval)ti; 死亡 Dead (void)exit; 3、线程的属性线程有两个重要的属性：名称和优先级 3.1 名称 name设置线程名用于记录线程，在出现异常时可以DeBug 3.2 优先级，也叫做“服务质量”。threadPriority，取值0到1.优先级或者服务质量高的，可以优先调用，只是说会优先调用，但是不是百分之百的优先调用，这里存在一个概率问题，内核里的算法调度线程的时候，只是把优先级作为一个考虑因素，还有很多个因数会决定哪个线程优先调用。这点得注意注意！！！ 下面是测试代码 12345678910111213141516171819202122232425- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event { //新建状态 NSThread *test1 = [[NSThread alloc] initWithTarget:self selector:@selector(demo) object:nil]; test1.name = @&quot;test1&quot;; //线程的优先级 test1.threadPriority = 1.0; //就绪状态 [test1 start]; //新建状态 NSThread *test2= [[NSThread alloc] initWithTarget:self selector:@selector(demo) object:nil]; test2.name = @&quot;test2&quot;; test2.threadPriority = 0; //就绪状态 [test2 start]; }//线程执行完成之后会自动销毁- (void)demo { for (int i = 0; i &lt; 20; i++) { NSLog(@&quot;%d--%@&quot;,i,[NSThread currentThread]); }} 控制台 123456789101112131415161718192021222324252627282930313233343536373839402016-02-16 22:43:28.182 05-线程状态[1241:78688] 0--&lt;NSThread: 0x7fead2017f30&gt;{number = 2, name = test1} 2016-02-16 22:43:28.182 05-线程状态[1241:78689] 0--&lt;NSThread: 0x7fead050a250&gt;{number = 3, name = test2} 2016-02-16 22:43:28.182 05-线程状态[1241:78688] 1--&lt;NSThread: 0x7fead2017f30&gt;{number = 2, name = test1} 2016-02-16 22:43:28.182 05-线程状态[1241:78688] 2--&lt;NSThread: 0x7fead2017f30&gt;{number = 2, name = test1} 2016-02-16 22:43:28.182 05-线程状态[1241:78689] 1--&lt;NSThread: 0x7fead050a250&gt;{number = 3, name = test2} 2016-02-16 22:43:28.183 05-线程状态[1241:78688] 3--&lt;NSThread: 0x7fead2017f30&gt;{number = 2, name = test1} 2016-02-16 22:43:28.183 05-线程状态[1241:78689] 2--&lt;NSThread: 0x7fead050a250&gt;{number = 3, name = test2} 2016-02-16 22:43:28.183 05-线程状态[1241:78688] 4--&lt;NSThread: 0x7fead2017f30&gt;{number = 2, name = test1} 2016-02-16 22:43:28.183 05-线程状态[1241:78688] 5--&lt;NSThread: 0x7fead2017f30&gt;{number = 2, name = test1} 2016-02-16 22:43:28.183 05-线程状态[1241:78689] 3--&lt;NSThread: 0x7fead050a250&gt;{number = 3, name = test2} 2016-02-16 22:43:28.183 05-线程状态[1241:78688] 6--&lt;NSThread: 0x7fead2017f30&gt;{number = 2, name = test1} 2016-02-16 22:43:28.183 05-线程状态[1241:78688] 7--&lt;NSThread: 0x7fead2017f30&gt;{number = 2, name = test1} 2016-02-16 22:43:28.183 05-线程状态[1241:78689] 4--&lt;NSThread: 0x7fead050a250&gt;{number = 3, name = test2} 2016-02-16 22:43:28.183 05-线程状态[1241:78688] 8--&lt;NSThread: 0x7fead2017f30&gt;{number = 2, name = test1} 2016-02-16 22:43:28.184 05-线程状态[1241:78688] 9--&lt;NSThread: 0x7fead2017f30&gt;{number = 2, name = test1} 2016-02-16 22:43:28.184 05-线程状态[1241:78688] 10--&lt;NSThread: 0x7fead2017f30&gt;{number = 2, name = test1} 2016-02-16 22:43:28.184 05-线程状态[1241:78689] 5--&lt;NSThread: 0x7fead050a250&gt;{number = 3, name = test2} 2016-02-16 22:43:28.184 05-线程状态[1241:78688] 11--&lt;NSThread: 0x7fead2017f30&gt;{number = 2, name = test1} 2016-02-16 22:43:28.184 05-线程状态[1241:78689] 6--&lt;NSThread: 0x7fead050a250&gt;{number = 3, name = test2} 2016-02-16 22:43:28.184 05-线程状态[1241:78688] 12--&lt;NSThread: 0x7fead2017f30&gt;{number = 2, name = test1} 2016-02-16 22:43:28.184 05-线程状态[1241:78688] 13--&lt;NSThread: 0x7fead2017f30&gt;{number = 2, name = test1} 2016-02-16 22:43:28.184 05-线程状态[1241:78689] 7--&lt;NSThread: 0x7fead050a250&gt;{number = 3, name = test2} 2016-02-16 22:43:28.184 05-线程状态[1241:78688] 14--&lt;NSThread: 0x7fead2017f30&gt;{number = 2, name = test1} 2016-02-16 22:43:28.184 05-线程状态[1241:78688] 15--&lt;NSThread: 0x7fead2017f30&gt;{number = 2, name = test1} 2016-02-16 22:43:28.185 05-线程状态[1241:78688] 16--&lt;NSThread: 0x7fead2017f30&gt;{number = 2, name = test1} 2016-02-16 22:43:28.184 05-线程状态[1241:78689] 8--&lt;NSThread: 0x7fead050a250&gt;{number = 3, name = test2} 2016-02-16 22:43:28.185 05-线程状态[1241:78688] 17--&lt;NSThread: 0x7fead2017f30&gt;{number = 2, name = test1} 2016-02-16 22:43:28.185 05-线程状态[1241:78688] 18--&lt;NSThread: 0x7fead2017f30&gt;{number = 2, name = test1} 2016-02-16 22:43:28.185 05-线程状态[1241:78689] 9--&lt;NSThread: 0x7fead050a250&gt;{number = 3, name = test2} 2016-02-16 22:43:28.185 05-线程状态[1241:78688] 19--&lt;NSThread: 0x7fead2017f30&gt;{number = 2, name = test1} 2016-02-16 22:43:28.185 05-线程状态[1241:78689] 10--&lt;NSThread: 0x7fead050a250&gt;{number = 3, name = test2} 2016-02-16 22:43:28.186 05-线程状态[1241:78689] 11--&lt;NSThread: 0x7fead050a250&gt;{number = 3, name = test2} 2016-02-16 22:43:28.186 05-线程状态[1241:78689] 12--&lt;NSThread: 0x7fead050a250&gt;{number = 3, name = test2} 2016-02-16 22:43:28.186 05-线程状态[1241:78689] 13--&lt;NSThread: 0x7fead050a250&gt;{number = 3, name = test2} 2016-02-16 22:43:28.186 05-线程状态[1241:78689] 14--&lt;NSThread: 0x7fead050a250&gt;{number = 3, name = test2} 2016-02-16 22:43:28.187 05-线程状态[1241:78689] 15--&lt;NSThread: 0x7fead050a250&gt;{number = 3, name = test2} 2016-02-16 22:43:28.187 05-线程状态[1241:78689] 16--&lt;NSThread: 0x7fead050a250&gt;{number = 3, name = test2} 2016-02-16 22:43:28.187 05-线程状态[1241:78689] 17--&lt;NSThread: 0x7fead050a250&gt;{number = 3, name = test2} 2016-02-16 22:43:28.187 05-线程状态[1241:78689] 18--&lt;NSThread: 0x7fead050a250&gt;{number = 3, name = test2} 2016-02-16 22:43:28.187 05-线程状态[1241:78689] 19--&lt;NSThread: 0x7fead050a250&gt;{number = 3, name = test2} 结论：优先级高，不一定先执行，只能说明先执行的概率要大一些！！！ 四、互斥锁1、访问共享资源引入问题！1.1 问题？ 不同的线程要访问共享的资源，而且对共享的资源做操作，由于上面结论得出服务质量和优先级不能决定线程执行的先后顺序，那么问题来了，一个线程对共享资源做了修改，而另外一个线程拿到的是未被修改之前资源，这是这个线程也对该资源做了修改，现在请问，两个线程都对该资源做了不同的修改，那么这个修改应该算谁的？！？！这就是问题所在！！！ 1.2 问题分析 1.3 问题解决 解决方案很简单，就是用一把锁锁住共享资源，等待线程1对其操作完毕后再打开，让线程2来执行，这就是传说中的互斥锁！！！ 2、互斥锁介绍2.1 互斥锁代码@synchronized(锁对象) { 需要锁定的代码 } 2.2 互斥锁的作用可以防止因多线程执行顺序不定导致的抢夺资源造成的数据安全的问题 2.3 真相：互斥锁其实就是同步的意思，也就是按顺序执行！ 3、互斥锁原理每个NSObject对象内部都有一把锁，当线程要进入synchronized到对象的时候就要判断，锁是否被打开，如果打开，进入执行，如果锁住，继续等待，这就是互斥锁的原理！ 4、互斥锁和自旋锁自旋锁就是atomic！ 4.1 原子属性和非原子属性（nonatomic 和 atomic） nonatomic:非原子属性，不会为 setter 方法加锁。 atomic: 原子属性，为 setter 方法加锁(默认就是atomic)。 通过给 setter 加锁，可以保证同一时间只有一个线程能够执行写入操作(setter)，但是同一时间允许多个线程执行读取操作(getter)。atomic本身就有一把自旋锁。这个特点叫做”单写多读”: 单个线程写入，多个线程读取。 atomic 只能保证写入数据的时候是安全的，但不能保证同时读写的时候是安全的。所以，不常使用！ 4.2 nonatomic 和 atomic 的对比 atomic：线程安全(执行setter方法的时候)，需要消耗大量的资源。 nonatomic：非线程安全，适合内存小的移动设备。 4.3 互斥锁和自旋锁的区别互斥锁如果发现其它线程正在执行锁定代码，线程会进入休眠(阻塞状态)，等其它线程时间片到了打开锁后，线程就会被唤醒(执行)。 自旋锁如果发现有其它线程正在执行锁定代码，线程会以死循环的方式，一直等待锁定的代码执行完成。 五、GCD1、GCD介绍 全称Grand Central Dispatch,可翻译为”牛逼的中枢调度器” 纯C语言开发，是苹果公司为多核的并行运算提出的解决方案，会自动利用更多的CPU内核（比如双核、四核），可以自动管理线程的生命周期（创建线程、调度任务、销毁线程）。 2、GCD的两个核心2.1 任务 执行的操作,在GCD中，任务是通过 block来封装的。并且任务的block没有参数也没有返回值。 2.2 队列 存放任务 包括 串行队列 并发队列 主队列 全局队列 队列的类型 3、函数3.1 GCD函数3.1.1 同步 dispatch_sync同步：任务会在当前线程执行，因为同步函数不具备开新线程的能力。1void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block); 3.1.2 异步 dispatch_async异步：任务会在子线程执行，因为异步函数具备开新线程的能力。1void dispatch_async(dispatch_queue_t queue, dispatch_block_t block); 3.2 GCD使用步骤: 创建队列，或则获取队列 创建任务 将任务添加到队列中 GCD会自动将队列中的任务取出，放到对应的线程中执行 任务取出遵循队列的FIFO原则：先进先出，后进后出 示例代码 123456789// 1\\. 获取全局队列dispatch_queue_t queue = dispatch_get_global_queue(0, 0);// 2\\. 创建任务dispatch_block_t task = ^ { NSLog(@&quot;hello %@&quot;, [NSThread currentThread]);};// 3\\. 将任务添加到队列，并且指定执行任务的函数dispatch_async(queue, task); 通常写成一句代码 123dispatch_async(dispatch_get_global_queue(0, 0), ^{ NSLog(@&quot;hello %@&quot;, [NSThread currentThread]); }); 4、串行队列和并发队列4.1 串行队列 Serial Dispatch Queue4.1.1 特点 先进先出，按照顺序执行,并且一次只能调用一个任务 无论队列中所指定的执行任务的函数是同步还是异步，都必须等待前一个任务执行完毕才可以调用后面的人 4.1.2 创建一个串行队列 方法一 1dispatch_queue_t queue = dispatch_queue_create(&quot;test&quot;, DISPATCH_QUEUE_SERIAL); 方法二 1dispatch_queue_t queue = dispatch_queue_create(&quot;test&quot;, NULL); 4.1.3 串行队列，同步执行代码： 12345678// 1、创建串行队列dispatch_queue_t queue = dispatch_queue_create(&quot;test&quot;, DISPATCH_QUEUE_SERIAL);// 2、将任务添加到队列，并且指定同步执行for (int i = 0; i &lt; 10; i++) { dispatch_sync(queue, ^{ NSLog(@&quot;%@--%d&quot;,[NSThread currentThread],i); });} 打印结果： 123456789102016-02-25 16:31:07.849 test[1924:376468] &lt;NSThread: 0x7ff040404370&gt;{number = 1, name = main}--0 2016-02-25 16:31:07.849 test[1924:376468] &lt;NSThread: 0x7ff040404370&gt;{number = 1, name = main}--1 2016-02-25 16:31:07.849 test[1924:376468] &lt;NSThread: 0x7ff040404370&gt;{number = 1, name = main}--2 2016-02-25 16:31:07.849 test[1924:376468] &lt;NSThread: 0x7ff040404370&gt;{number = 1, name = main}--3 2016-02-25 16:31:07.849 test[1924:376468] &lt;NSThread: 0x7ff040404370&gt;{number = 1, name = main}--4 2016-02-25 16:31:07.849 test[1924:376468] &lt;NSThread: 0x7ff040404370&gt;{number = 1, name = main}--5 2016-02-25 16:31:07.850 test[1924:376468] &lt;NSThread: 0x7ff040404370&gt;{number = 1, name = main}--6 2016-02-25 16:31:07.850 test[1924:376468] &lt;NSThread: 0x7ff040404370&gt;{number = 1, name = main}--7 2016-02-25 16:31:07.850 test[1924:376468] &lt;NSThread: 0x7ff040404370&gt;{number = 1, name = main}--8 2016-02-25 16:31:07.850 test[1924:376468] &lt;NSThread: 0x7ff040404370&gt;{number = 1, name = main}--9 结论：串行队列，同步执行，不开新线程，按顺序执行 4.1.4 串行队列，异步执行代码： 12345678// 1、创建串行队列dispatch_queue_t queue = dispatch_queue_create(&quot;test&quot;, DISPATCH_QUEUE_SERIAL);// 2、将任务添加到队列，并且指定同步执行for (int i = 0; i &lt; 10; i++) { dispatch_async(queue, ^{ NSLog(@&quot;%@--%d&quot;,[NSThread currentThread],i); });} 打印结果： 123456789102016-02-25 17:08:32.167 test[1959:391722] &lt;NSThread: 0x7fbb98d24fa0&gt;{number = 2, name = (null)}--0 2016-02-25 17:08:32.168 test[1959:391722] &lt;NSThread: 0x7fbb98d24fa0&gt;{number = 2, name = (null)}--1 2016-02-25 17:08:32.168 test[1959:391722] &lt;NSThread: 0x7fbb98d24fa0&gt;{number = 2, name = (null)}--2 2016-02-25 17:08:32.168 test[1959:391722] &lt;NSThread: 0x7fbb98d24fa0&gt;{number = 2, name = (null)}--3 2016-02-25 17:08:32.168 test[1959:391722] &lt;NSThread: 0x7fbb98d24fa0&gt;{number = 2, name = (null)}--4 2016-02-25 17:08:32.168 test[1959:391722] &lt;NSThread: 0x7fbb98d24fa0&gt;{number = 2, name = (null)}--5 2016-02-25 17:08:32.169 test[1959:391722] &lt;NSThread: 0x7fbb98d24fa0&gt;{number = 2, name = (null)}--6 2016-02-25 17:08:32.169 test[1959:391722] &lt;NSThread: 0x7fbb98d24fa0&gt;{number = 2, name = (null)}--7 2016-02-25 17:08:32.169 test[1959:391722] &lt;NSThread: 0x7fbb98d24fa0&gt;{number = 2, name = (null)}--8 2016-02-25 17:08:32.169 test[1959:391722] &lt;NSThread: 0x7fbb98d24fa0&gt;{number = 2, name = (null)}--9 结论：串行队列，异步执行，开启一条新的线程，按顺序执行 4.2 并发队列 Concurrent Dispatch Queue4.2.1 特点 并发同时调度队列中的任务去执行 如果当前调度的任务是同步执行的，会等待当前任务执行完毕后，再调度后续的任务 如果当前调度的任务是异步执行的，同时底层线程池有可用的线程资源，就不会等待当前任务，直接调度任务到新线程去执行。 4.2.2 创建并发队列1dispatch_queue_t q = dispatch_queue_create(&quot;test&quot;, DISPATCH_QUEUE_CONCURRENT); 4.2.3 并发队列，同步执行代码： 12345678// 1\\. 创建并发队列dispatch_queue_t queue = dispatch_queue_create(&quot;test&quot;, DISPATCH_QUEUE_CONCURRENT);// 2\\. 将任务添加到队列, 并且指定同步执行for (int i = 0; i &lt; 10; i++) { dispatch_sync(queue, ^{ NSLog(@&quot;%@ %d&quot;, [NSThread currentThread], i); });} 输出： 123456789102016-02-25 17:18:38.039 test[1979:399667] &lt;NSThread: 0x7ffef86024b0&gt;{number = 1, name = main} 0 2016-02-25 17:18:38.040 test[1979:399667] &lt;NSThread: 0x7ffef86024b0&gt;{number = 1, name = main} 1 2016-02-25 17:18:38.040 test[1979:399667] &lt;NSThread: 0x7ffef86024b0&gt;{number = 1, name = main} 2 2016-02-25 17:18:38.040 test[1979:399667] &lt;NSThread: 0x7ffef86024b0&gt;{number = 1, name = main} 3 2016-02-25 17:18:38.040 test[1979:399667] &lt;NSThread: 0x7ffef86024b0&gt;{number = 1, name = main} 4 2016-02-25 17:18:38.040 test[1979:399667] &lt;NSThread: 0x7ffef86024b0&gt;{number = 1, name = main} 5 2016-02-25 17:18:38.040 test[1979:399667] &lt;NSThread: 0x7ffef86024b0&gt;{number = 1, name = main} 6 2016-02-25 17:18:38.040 test[1979:399667] &lt;NSThread: 0x7ffef86024b0&gt;{number = 1, name = main} 7 2016-02-25 17:18:38.040 test[1979:399667] &lt;NSThread: 0x7ffef86024b0&gt;{number = 1, name = main} 8 2016-02-25 17:18:38.041 test[1979:399667] &lt;NSThread: 0x7ffef86024b0&gt;{number = 1, name = main} 9 结论:并发队列，同步执行，不开线程，顺序执行 4.2.4 并发队列，异步执行代码： 12345678// 1\\. 创建并发队列dispatch_queue_t queue = dispatch_queue_create(&quot;test&quot;, DISPATCH_QUEUE_CONCURRENT);// 2\\. 将任务添加到队列, 并且指定同步执行for (int i = 0; i &lt; 10; i++) { dispatch_async(queue, ^{ NSLog(@&quot;%@ %d&quot;, [NSThread currentThread], i); });} 输出： 123456789102016-02-25 17:22:59.357 test[1992:403694] &lt;NSThread: 0x7fe531c1a9b0&gt;{number = 7, name = (null)} 6 2016-02-25 17:22:59.356 test[1992:403684] &lt;NSThread: 0x7fe531d18fa0&gt;{number = 3, name = (null)} 1 2016-02-25 17:22:59.356 test[1992:403689] &lt;NSThread: 0x7fe534300610&gt;{number = 5, name = (null)} 3 2016-02-25 17:22:59.356 test[1992:403683] &lt;NSThread: 0x7fe531e94d80&gt;{number = 2, name = (null)} 0 2016-02-25 17:22:59.356 test[1992:403692] &lt;NSThread: 0x7fe531e9df80&gt;{number = 6, name = (null)} 4 2016-02-25 17:22:59.356 test[1992:403693] &lt;NSThread: 0x7fe531d18f40&gt;{number = 8, name = (null)} 5 2016-02-25 17:22:59.356 test[1992:403695] &lt;NSThread: 0x7fe5343015e0&gt;{number = 9, name = (null)} 7 2016-02-25 17:22:59.357 test[1992:403688] &lt;NSThread: 0x7fe531c16e30&gt;{number = 4, name = (null)} 2 2016-02-25 17:22:59.357 test[1992:403694] &lt;NSThread: 0x7fe531c1a9b0&gt;{number = 7, name = (null)} 9 2016-02-25 17:22:59.357 test[1992:403696] &lt;NSThread: 0x7fe531c237a0&gt;{number = 10, name = (null)} 8 结论：开启足够多的线程，不按照顺序执行CPU在调度的时候以最高效的方式调度和执行任务，所以会开启多条线程，因为并发，执行顺序不一定 5、主队列5.1 主队列 主队列是系统提供的，无需自己创建，可以通过dispatch_get_main_queue()函数来获取。 5.2 特点 添加到主队列的任务只能由主线程来执行。 先进先出的，只有当主线程的代码执行完毕后，主队列才会调度任务到主线程执行 5.3 主队列 异步执行代码 12345678910// 1\\. 获取主队列dispatch_queue_t q = dispatch_get_main_queue();// 2\\. 将任务添加到主队列, 并且指定异步执行for (int i = 0; i &lt; 10; i++) { dispatch_async(q, ^{ NSLog(@&quot;%@ %d&quot;, [NSThread currentThread], i); });}// 先执行完这句代码, 才会执行主队列中的任务NSLog(@&quot;hello %@&quot;, [NSThread currentThread]); 打印 12345678910112016-02-25 21:10:43.293 test[773:786816] hello &lt;NSThread: 0x7ff158c05940&gt;{number = 1, name = main} 2016-02-25 21:10:43.295 test[773:786816] &lt;NSThread: 0x7ff158c05940&gt;{number = 1, name = main} 0 2016-02-25 21:10:43.295 test[773:786816] &lt;NSThread: 0x7ff158c05940&gt;{number = 1, name = main} 1 2016-02-25 21:10:43.296 test[773:786816] &lt;NSThread: 0x7ff158c05940&gt;{number = 1, name = main} 2 2016-02-25 21:10:43.296 test[773:786816] &lt;NSThread: 0x7ff158c05940&gt;{number = 1, name = main} 3 2016-02-25 21:10:43.296 test[773:786816] &lt;NSThread: 0x7ff158c05940&gt;{number = 1, name = main} 4 2016-02-25 21:10:43.296 test[773:786816] &lt;NSThread: 0x7ff158c05940&gt;{number = 1, name = main} 5 2016-02-25 21:10:43.296 test[773:786816] &lt;NSThread: 0x7ff158c05940&gt;{number = 1, name = main} 6 2016-02-25 21:10:43.296 test[773:786816] &lt;NSThread: 0x7ff158c05940&gt;{number = 1, name = main} 7 2016-02-25 21:10:43.296 test[773:786816] &lt;NSThread: 0x7ff158c05940&gt;{number = 1, name = main} 8 2016-02-25 21:10:43.296 test[773:786816] &lt;NSThread: 0x7ff158c05940&gt;{number = 1, name = main} 9 打印结果得出的一些结论 在主线程顺序执行，不开启新的线程 主队列的特点：只有当主线程空闲时，主队列才会调度任务到主线程执行 主队列就算是异步执行也不会开启新的线程 主队列相当于一个全局的串行队列 主队列和串行队列的区别 串行队列:必须等待一个任务执行完毕，才会调度下一个任务。 主队列:如果主线程上有代码执行，主队列就不调度任务。 5.4 主队列 同步执行（死锁）代码 1234567891011NSLog(@&quot;begin&quot;);// 1\\. 获取主队列dispatch_queue_t q = dispatch_get_main_queue();// 2\\. 将任务添加到主队列, 并且指定同步执行// 死锁for (int i = 0; i &lt; 10; i++) { dispatch_sync(q, ^{ NSLog(@&quot;%@ %d&quot;, [NSThread currentThread], i); });}NSLog(@&quot;end&quot;); 打印 12016-02-25 21:19:25.986 test[791:790967] begin 打印结果可以看出，不是想要的结果，这时候发生了死锁，在主线程执行，主队列同步执行任务，会发生死锁，主线程和主队列同步任务相互等待，造成死锁 解决办法代码 1234567891011121314NSLog(@&quot;begin&quot;);dispatch_async(dispatch_get_global_queue(0, 0), ^{ NSLog(@&quot;--- %@&quot;, [NSThread currentThread]); // 1\\. 获取主队列 dispatch_queue_t q = dispatch_get_main_queue(); // 2\\. 将任务添加到主队列, 并且指定同步执行 // 死锁 for (int i = 0; i &lt; 10; i++) { dispatch_sync(q, ^{ NSLog(@&quot;%@ %d&quot;, [NSThread currentThread], i); }); }});NSLog(@&quot;end&quot;); 打印 123456789101112132016-02-25 21:23:23.205 test[803:794826] begin 2016-02-25 21:23:23.206 test[803:794826] end 2016-02-25 21:23:23.206 test[803:794866] --- &lt;NSThread: 0x7f8830514cb0&gt;{number = 2, name = (null)} 2016-02-25 21:23:23.209 test[803:794826] &lt;NSThread: 0x7f8830507dd0&gt;{number = 1, name = main} 0 2016-02-25 21:23:23.209 test[803:794826] &lt;NSThread: 0x7f8830507dd0&gt;{number = 1, name = main} 1 2016-02-25 21:23:23.209 test[803:794826] &lt;NSThread: 0x7f8830507dd0&gt;{number = 1, name = main} 2 2016-02-25 21:23:23.209 test[803:794826] &lt;NSThread: 0x7f8830507dd0&gt;{number = 1, name = main} 3 2016-02-25 21:23:23.209 test[803:794826] &lt;NSThread: 0x7f8830507dd0&gt;{number = 1, name = main} 4 2016-02-25 21:23:23.210 test[803:794826] &lt;NSThread: 0x7f8830507dd0&gt;{number = 1, name = main} 5 2016-02-25 21:23:23.210 test[803:794826] &lt;NSThread: 0x7f8830507dd0&gt;{number = 1, name = main} 6 2016-02-25 21:23:23.210 test[803:794826] &lt;NSThread: 0x7f8830507dd0&gt;{number = 1, name = main} 7 2016-02-25 21:23:23.210 test[803:794826] &lt;NSThread: 0x7f8830507dd0&gt;{number = 1, name = main} 8 2016-02-25 21:23:23.210 test[803:794826] &lt;NSThread: 0x7f8830507dd0&gt;{number = 1, name = main} 9 打印结果可以看出，当我们将主队列同步执行任务放到子线程去执行，就不会出现死锁。由于将主队列同步放到了子线程中执行，主队列同步任务无法阻塞主线程执行代码，因此主线程可以将主线程上的代码执行完毕。当主线程执行完毕之后，就会执行主队列里面的任务。 6、全局队列全局队列是系统提供的，无需自己创建，可以直接通过dispatch_get_global_queue(long identifier, unsigned long flags);函数来获取。 6.1 全局队列 异步执行代码 12345678// 1\\. 获取全局队列dispatch_queue_t q = dispatch_get_global_queue(0, 0);// 2\\. 将任务添加到全局队列, 异步执行for (int i = 0; i &lt; 10; i++) { dispatch_async(q, ^{ NSLog(@&quot;%d %@&quot;, i, [NSThread currentThread]); });} 打印输出 123456789102016-02-25 21:29:06.978 test[816:799523] 1 &lt;NSThread: 0x7fd428e15760&gt;{number = 3, name = (null)} 2016-02-25 21:29:06.978 test[816:799530] 4 &lt;NSThread: 0x7fd428d2fbb0&gt;{number = 6, name = (null)} 2016-02-25 21:29:06.978 test[816:799522] 0 &lt;NSThread: 0x7fd428f094e0&gt;{number = 2, name = (null)} 2016-02-25 21:29:06.978 test[816:799529] 3 &lt;NSThread: 0x7fd428c0e1b0&gt;{number = 5, name = (null)} 2016-02-25 21:29:06.978 test[816:799532] 6 &lt;NSThread: 0x7fd428f06740&gt;{number = 7, name = (null)} 2016-02-25 21:29:06.978 test[816:799533] 7 &lt;NSThread: 0x7fd428d37be0&gt;{number = 8, name = (null)} 2016-02-25 21:29:06.978 test[816:799531] 5 &lt;NSThread: 0x7fd428e0c490&gt;{number = 9, name = (null)} 2016-02-25 21:29:06.978 test[816:799526] 2 &lt;NSThread: 0x7fd428d3e4b0&gt;{number = 4, name = (null)} 2016-02-25 21:29:06.979 test[816:799534] 8 &lt;NSThread: 0x7fd428d36ab0&gt;{number = 10, name = (null)} 2016-02-25 21:29:06.979 test[816:799523] 9 &lt;NSThread: 0x7fd428e15760&gt;{number = 3, name = (null)} 特点： 全局队列的工作特性跟并发队列一致。 实际上，全局队列就是系统为了方便程序员，专门提供的一种特殊的并发队列。 全局队列和并发队列的区别： 全局队列没有名称，无论ARC还是MRC都不需要考虑内存释放，日常开发，建议使用全局队列 并发队列有名称，如果在MRC开发中，需要使用dispatch_release来释放相应的对象，dispatch_barrier 必须使用自定义的并发队列，开发第三方框架，建议使用并发队列 6.2、函数1dispatch_get_global_queue(long identifier, unsigned long flags); 这个函数中有两个参数:第一个参数: identifier iOS7.0，表示的是优先级:DISPATCH_QUEUE_PRIORITY_HIGH = 2; 高优先级DISPATCH_QUEUE_PRIORITY_DEFAULT = 0; 默认优先级DISPATCH_QUEUE_PRIORITY_LOW = -2; 低优先级DISPATCH_QUEUE_PRIORITY_BACKGROUND = INT16_MIN; 后台优先级iOS8.0开始，推荐使用服务质量(QOS):QOS_CLASS_USER_INTERACTIVE = 0x21; 用户交互QOS_CLASS_USER_INITIATED = 0x19; 用户期望QOS_CLASS_DEFAULT = 0x15; 默认QOS_CLASS_UTILITY = 0x11; 实用工具QOS_CLASS_BACKGROUND = 0x09; 后台QOS_CLASS_UNSPECIFIED = 0x00; 未指定通过对比可知: 第一个参数传入0，可以同时适配iOS7及iOS7以后的版本。服务质量和优先级是一一对应的: 1234DISPATCH_QUEUE_PRIORITY_HIGH: QOS_CLASS_USER_INITIATED DISPATCH_QUEUE_PRIORITY_DEFAULT: QOS_CLASS_DEFAULT DISPATCH_QUEUE_PRIORITY_LOW: QOS_CLASS_UTILITY DISPATCH_QUEUE_PRIORITY_BACKGROUND: QOS_CLASS_BACKGROUND 第二个参数: flags 为未来保留使用的，始终传入0。Reserved for future use. 7、GCD总结1、开不开线程，由执行任务的函数决定 同步执行不开线程 异步执行开线程 2、异步执行任务，开几条线程由队列决定 串行队列，只会开一条线程，因为一条就足够了 并发队列，可以开多条线程，具体开几条由线程池决定 对主队列而言，不管是同步执行还是异步执行，都不会开线程。 最后盗图总结一张 六、NSOperation1、NSOperation简介1.1 NSOperation与GCD的区别： OC语言中基于 GCD 的面向对象的封装; 使用起来比 GCD 更加简单; 提供了一些用 GCD 不好实现的功能; 苹果推荐使用，使用 NSOperation 程序员不用关心线程的生命周期 1.2NSOperation的特点 NSOperation 是一个抽象类，抽象类不能直接使用,必须使用它的子类 抽象类的用处是定义子类共有的属性和方法 2、核心概念 将操作添加到队列，异步执行。相对于GCD创建任务，将任务添加到队列。 将NSOperation添加到NSOperationQueue就可以实现多线程编程 3、操作步骤 先将需要执行的操作封装到一个NSOperation对象中 然后将NSOperation对象添加到NSOperationQueue中 系统会自动将NSOperationQueue中的NSOperation取出来 将取出的NSOperation封装的操作放到一条新线程中执行 4、NSInvocationOperation方式一代码 123456789101112- (void)viewDidLoad { [super viewDidLoad]; //创建操作，然后调用操作的start方法 NSInvocationOperation *op = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(demo) object:nil]; NSLog(@&quot;%d&quot;,op.isFinished); [op start]; NSLog(@&quot;%d&quot;,op.isFinished); }- (void)demo { NSLog(@&quot;hello %@&quot;,[NSThread currentThread]); } 打印输出 1232016-02-25 22:12:30.054 test[892:834660] 0 2016-02-25 22:12:30.054 test[892:834660] hello &lt;NSThread: 0x7fad12704f80&gt;{number = 1, name = main} 2016-02-25 22:12:30.054 test[892:834660] 1 结论：[op start]在主线程中调用的，所以执行的线程也会是在主线程执行！ 重复调用start也只会执行一次，因为NSOperation会有一个属性去记住，是否已经完成了该操作！ 方式二代码 12345678910111213- (void)viewDidLoad { [super viewDidLoad]; // 创建操作，将操作添加到NSOperationQueue中，然后就会异步的自动执行 NSInvocationOperation *op = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(demo) object:nil]; //队列 NSOperationQueue *queue = [[NSOperationQueue alloc] init]; //把操作添加到队列 [queue addOperation:op]; }- (void)demo { NSLog(@&quot;hello %@&quot;,[NSThread currentThread]); } 打印 12016-02-25 22:21:44.999 test[912:842412] hello &lt;NSThread: 0x7fab92610080&gt;{number = 2, name = (null)} 将操作添加到NSOperationQueue中，然后就会异步的自动执行 5、NSBlockOperation NSBlockOperation 中使用block的方式让所有代码逻辑在一起，使用起来更加简便。** 方式一代码 123456//创建操作 NSBlockOperation *op = [NSBlockOperation blockOperationWithBlock:^{ NSLog(@&quot;hello %@&quot;,[NSThread currentThread]); }]; //更新op的状态，执行main方法，不会开新线程 [op start]; 输出 12016-02-25 22:25:30.442 test[923:846208] hello &lt;NSThread: 0x7fd410d055a0&gt;{number = 1, name = main} 方式二代码 123456// 创建队列，创建操作，将操作添加到队列中执行 NSOperationQueue *queue = [[NSOperationQueue alloc] init]; NSBlockOperation *op = [NSBlockOperation blockOperationWithBlock:^{ NSLog(@&quot;hello %@&quot;,[NSThread currentThread]); }]; [queue addOperation:op]; 输出 12016-02-25 22:26:48.064 test[934:848038] hello &lt;NSThread: 0x7fc6bbb24c80&gt;{number = 2, name = (null)} 方式三代码 123456NSOperationQueue *queue = [[NSOperationQueue alloc] init];[queue addOperationWithBlock:^{ NSLog(@&quot;hello %@&quot;,[NSThread currentThread]);}]; 输出 12016-02-25 22:27:56.445 test[945:850128] hello &lt;NSThread: 0x7f98dbc2cae0&gt;{number = 2, name = (null)} 创建队列，添加block形式的操作 七、案例线程之间的通信问题技术方案：NSOperation123456[self.queue addOperationWithBlock:^{ NSLog(@&quot;异步下载图片&quot;); [[NSOperationQueue mainQueue] addOperationWithBlock:^{ NSLog(@&quot;回到主线程，更新UI&quot;); }]; }]; 技术方案：GCD123456dispatch_async(dispatch_get_global_queue(0, 0), ^{ NSLog(@&quot;下载图片---%@&quot;,[NSThread currentThread]); dispatch_async(dispatch_get_main_queue(), ^{ NSLog(@&quot;回到主线程刷新图片的显示 -%@&quot;,[NSThread currentThread]); });});","link":"/2023/03/24/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"tags":[],"categories":[]}